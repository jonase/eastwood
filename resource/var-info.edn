;; See comments before function print-var-info-summary in namespace
;; eastwood.util for a description of what the data in this file is
;; used for.

;; Run the following command to get a summary of what is in this file,
;; and a comparison of what is in this file vs. what is defined in
;; Clojure namespaces:

;; 'lein eastwood '{:debug [:var-info]}'

{clojure.core.protocols/CollReduce {:var-kind nil, :macro nil},
 clojure.core.protocols/IKVReduce {:var-kind nil, :macro nil},
 clojure.core.protocols/InternalReduce {:var-kind nil, :macro nil},
 clojure.core.protocols/arr-impl {:var-kind nil, :macro nil},
 clojure.core.protocols/coll-reduce {:var-kind nil, :macro nil},
 clojure.core.protocols/emit-array-impls {:var-kind nil, :macro true},
 clojure.core.protocols/internal-reduce {:var-kind nil, :macro nil},
 clojure.core.protocols/kv-reduce {:var-kind nil, :macro nil},
 clojure.core.reducers/->Cat {:var-kind nil, :macro nil},
 clojure.core.reducers/CollFold {:var-kind nil, :macro nil},
 clojure.core.reducers/append! {:var-kind nil, :macro nil},
 clojure.core.reducers/cat {:var-kind nil, :macro nil},
 clojure.core.reducers/coll-fold {:var-kind nil, :macro nil},
 clojure.core.reducers/drop {:var-kind nil, :macro nil},
 clojure.core.reducers/filter {:var-kind nil, :macro nil},
 clojure.core.reducers/fjtask {:var-kind nil, :macro nil},
 clojure.core.reducers/flatten {:var-kind nil, :macro nil},
 clojure.core.reducers/fold {:var-kind nil, :macro nil},
 clojure.core.reducers/foldcat {:var-kind nil, :macro nil},
 clojure.core.reducers/folder {:var-kind nil, :macro nil},
 clojure.core.reducers/map {:var-kind nil, :macro nil},
 clojure.core.reducers/mapcat {:var-kind nil, :macro nil},
 clojure.core.reducers/monoid {:var-kind nil, :macro nil},
 clojure.core.reducers/pool {:var-kind nil, :macro nil},
 clojure.core.reducers/reduce {:var-kind nil, :macro nil},
 clojure.core.reducers/reducer {:var-kind nil, :macro nil},
 clojure.core.reducers/remove {:var-kind nil, :macro nil},
 clojure.core.reducers/take {:var-kind nil, :macro nil},
 clojure.core.reducers/take-while {:var-kind nil, :macro nil},
 clojure.core/* {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/*' {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/*1 {:var-kind nil, :macro nil},
 clojure.core/*2 {:var-kind nil, :macro nil},
 clojure.core/*3 {:var-kind nil, :macro nil},
 clojure.core/*agent* {:var-kind nil, :macro nil},
 clojure.core/*allow-unresolved-vars* {:var-kind nil, :macro nil},
 clojure.core/*assert* {:var-kind nil, :macro nil},
 clojure.core/*clojure-version* {:var-kind nil, :macro nil},
 clojure.core/*command-line-args* {:var-kind nil, :macro nil},
 clojure.core/*compile-files* {:var-kind nil, :macro nil},
 clojure.core/*compile-path* {:var-kind nil, :macro nil},
 clojure.core/*compiler-options* {:var-kind nil, :macro nil},
 clojure.core/*data-readers* {:var-kind nil, :macro nil},
 clojure.core/*default-data-reader-fn* {:var-kind nil, :macro nil},
 clojure.core/*e {:var-kind nil, :macro nil},
 clojure.core/*err* {:var-kind nil, :macro nil},
 clojure.core/*file* {:var-kind nil, :macro nil},
 clojure.core/*flush-on-newline* {:var-kind nil, :macro nil},
 clojure.core/*fn-loader* {:var-kind nil, :macro nil},
 clojure.core/*in* {:var-kind nil, :macro nil},
 clojure.core/*math-context* {:var-kind nil, :macro nil},
 clojure.core/*ns* {:var-kind nil, :macro nil},
 clojure.core/*out* {:var-kind nil, :macro nil},
 clojure.core/*print-dup* {:var-kind nil, :macro nil},
 clojure.core/*print-length* {:var-kind nil, :macro nil},
 clojure.core/*print-level* {:var-kind nil, :macro nil},
 clojure.core/*print-meta* {:var-kind nil, :macro nil},
 clojure.core/*print-readably* {:var-kind nil, :macro nil},
 clojure.core/*read-eval* {:var-kind nil, :macro nil},
 clojure.core/*source-path* {:var-kind nil, :macro nil},
 clojure.core/*unchecked-math* {:var-kind nil, :macro nil},
 clojure.core/*use-context-classloader* {:var-kind nil, :macro nil},
 clojure.core/*verbose-defrecords* {:var-kind nil, :macro nil},
 clojure.core/*warn-on-reflection* {:var-kind nil, :macro nil},
 clojure.core/+ {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/+' {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/- {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/-' {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/-> {:var-kind nil, :macro true},
 clojure.core/->> {:var-kind nil, :macro true},
 clojure.core/->ArrayChunk {:var-kind nil, :macro nil},
 clojure.core/->Vec {:var-kind nil, :macro nil},
 clojure.core/->VecNode {:var-kind nil, :macro nil},
 clojure.core/->VecSeq {:var-kind nil, :macro nil},
 clojure.core/-cache-protocol-fn {:var-kind nil, :macro nil},
 clojure.core/-reset-methods {:var-kind nil, :macro nil, :side-effect true},
 clojure.core/.. {:var-kind nil, :macro true},
 clojure.core// {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/< {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/<= {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/= {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/== {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/> {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/>= {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/EMPTY-NODE {:var-kind nil, :macro nil},
 clojure.core/Throwable->map {:var-kind nil, :macro nil, :lazy false, :pure-fn true}
 clojure.core/accessor {:var-kind nil, :macro nil},
 clojure.core/aclone {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/add-classpath {:var-kind nil, :macro nil},
 clojure.core/add-watch {:var-kind nil, :macro nil},
 clojure.core/agent {:var-kind nil, :macro nil},
 clojure.core/agent-error {:var-kind nil, :macro nil},
 clojure.core/agent-errors {:var-kind nil, :macro nil},
 clojure.core/aget {:var-kind nil, :macro nil, :lazy false, :pure-fn true},  ; TBD: Might want a slightly different category for a function that is 'pure', but its return value depends on current contents of a mutable value
 clojure.core/alength {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/alias {:var-kind nil, :macro nil, :side-effect true},
 clojure.core/all-ns {:var-kind nil, :macro nil, :lazy false, :warn-if-ret-val-unused true},
 clojure.core/alter {:var-kind nil, :macro nil},
 clojure.core/alter-meta! {:var-kind nil, :macro nil, :side-effect true},
 clojure.core/alter-var-root {:var-kind nil, :macro nil, :side-effect true},
 clojure.core/amap {:var-kind nil, :macro true},   ; TBD: Can this mutate its args?
 clojure.core/ancestors {:var-kind nil, :macro nil},
 clojure.core/and {:var-kind nil, :macro true},
 clojure.core/apply {:var-kind nil, :macro nil, :lazy false, :pure-fn-if-fn-args-pure true},
 clojure.core/areduce {:var-kind nil, :macro true},  ; TBD: Same answer as amap ?
 clojure.core/array-map {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/as-> {:var-kind nil, :macro true},
 clojure.core/aset {:var-kind nil, :macro nil, :side-effect true},
 clojure.core/aset-boolean {:var-kind nil, :macro nil, :side-effect true},
 clojure.core/aset-byte {:var-kind nil, :macro nil, :side-effect true},
 clojure.core/aset-char {:var-kind nil, :macro nil, :side-effect true},
 clojure.core/aset-double {:var-kind nil, :macro nil, :side-effect true},
 clojure.core/aset-float {:var-kind nil, :macro nil, :side-effect true},
 clojure.core/aset-int {:var-kind nil, :macro nil, :side-effect true},
 clojure.core/aset-long {:var-kind nil, :macro nil, :side-effect true},
 clojure.core/aset-short {:var-kind nil, :macro nil, :side-effect true},
 clojure.core/assert {:var-kind nil, :macro true},
 clojure.core/assert-same-protocol {:var-kind nil, :macro nil, :side-effect true},
 clojure.core/assoc {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/assoc! {:var-kind nil, :macro nil, :lazy false, :warn-if-ret-val-unused true},
 clojure.core/assoc-in {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/associative? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/atom {:var-kind nil, :macro nil},
 clojure.core/await {:var-kind nil, :macro nil},
 clojure.core/await-for {:var-kind nil, :macro nil},
 clojure.core/await1 {:var-kind nil, :macro nil},
 clojure.core/bases {:var-kind nil, :macro nil},
 clojure.core/bean {:var-kind nil, :macro nil},
 clojure.core/bigdec {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/bigint {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/biginteger {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/binding {:var-kind nil, :macro true},
 clojure.core/bit-and {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/bit-and-not {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/bit-clear {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/bit-flip {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/bit-not {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/bit-or {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/bit-set {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/bit-shift-left {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/bit-shift-right {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/bit-test {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/bit-xor {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/boolean {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/boolean-array {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/booleans {:var-kind nil, :macro nil},
 clojure.core/bound-fn {:var-kind nil, :macro true},
 clojure.core/bound-fn* {:var-kind nil, :macro nil, :warn-if-ret-val-unused true},
 clojure.core/bound? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/butlast {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/byte {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/byte-array {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/bytes {:var-kind nil, :macro nil},
 clojure.core/case {:var-kind nil, :macro true},
 clojure.core/cast {:var-kind nil, :macro nil},
 clojure.core/cat {:var-kind nil, :macro nil}, ;; TBD: Are transducer fns pure?  Does it ever make sense to call one and ignore its return value?
 clojure.core/char {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/char-array {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/char-escape-string {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/char-name-string {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/char? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/chars {:var-kind nil, :macro nil},
 clojure.core/chunk {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/chunk-append {:var-kind nil, :macro nil, :side-effect true},
 clojure.core/chunk-buffer {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/chunk-cons {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/chunk-first {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/chunk-next {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/chunk-rest {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/chunked-seq? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/class {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/class? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/clear-agent-errors {:var-kind nil, :macro nil},
 clojure.core/clojure-version {:var-kind nil, :macro nil, :lazy false, :warn-if-ret-val-unused true},
 clojure.core/coll? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/comment {:var-kind nil, :macro true},
 clojure.core/commute {:var-kind nil, :macro nil},
 clojure.core/comp {:var-kind nil, :macro nil, :pure-if-fn-args-pure true},
 clojure.core/comparator {:var-kind nil, :macro nil, :pure-if-fn-args-pure true},
 clojure.core/compare {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/compare-and-set! {:var-kind nil, :macro nil},
 clojure.core/compile {:var-kind nil, :macro nil},
 clojure.core/complement {:var-kind nil, :macro nil, :pure-if-fn-args-pure true},
 clojure.core/concat {:var-kind nil, :macro nil, :lazy true, :pure-fn true},
 clojure.core/cond {:var-kind nil, :macro true},
 clojure.core/cond-> {:var-kind nil, :macro true},
 clojure.core/cond->> {:var-kind nil, :macro true},
 clojure.core/condp {:var-kind nil, :macro true},
 clojure.core/conj {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/conj! {:var-kind nil, :macro nil, :lazy false, :warn-if-ret-val-unused true},
 clojure.core/cons {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/constantly {:var-kind nil, :macro nil, :pure-if-fn-args-pure true},
 clojure.core/construct-proxy {:var-kind nil, :macro nil},
 clojure.core/contains? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/count {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/counted? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/create-ns {:var-kind nil, :macro nil, :side-effect true},
 clojure.core/create-struct {:var-kind nil, :macro nil},
 clojure.core/cycle {:var-kind nil, :macro nil, :lazy true, :pure-fn true},
 clojure.core/dec {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/dec' {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/decimal? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/declare {:var-kind nil, :macro true},
 clojure.core/default-data-readers {:var-kind nil, :macro nil},
 clojure.core/definline {:var-kind nil, :macro true},
 clojure.core/definterface {:var-kind nil, :macro true},
 clojure.core/defmacro {:var-kind nil, :macro true},
 clojure.core/defmethod {:var-kind nil, :macro true},
 clojure.core/defmulti {:var-kind nil, :macro true},
 clojure.core/defn {:var-kind nil, :macro true},
 clojure.core/defn- {:var-kind nil, :macro true},
 clojure.core/defonce {:var-kind nil, :macro true},
 clojure.core/defprotocol {:var-kind nil, :macro true},
 clojure.core/defrecord {:var-kind nil, :macro true},
 clojure.core/defstruct {:var-kind nil, :macro true},
 clojure.core/deftype {:var-kind nil, :macro true},
 clojure.core/delay {:var-kind nil, :macro true},
 clojure.core/delay? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/deliver {:var-kind nil, :macro nil, :side-effect true},
 clojure.core/denominator {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/deref {:var-kind nil, :macro nil},
 clojure.core/derive {:var-kind nil, :macro nil, :side-effect true},
 clojure.core/descendants {:var-kind nil, :macro nil},
 clojure.core/destructure {:var-kind nil, :macro nil},
 clojure.core/disj {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/disj! {:var-kind nil, :macro nil, :lazy false, :warn-if-ret-val-unused true},
 clojure.core/dissoc {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/dissoc! {:var-kind nil, :macro nil, :lazy false, :warn-if-ret-val-unused true},
 clojure.core/distinct {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/distinct? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/doall {:var-kind nil, :macro nil, :lazy false, :warn-if-ret-val-unused true},  ; TBD: Consider making a special warning just for this one, suggesting to use dorun instead if the return value is not needed, potentially saving memory
 clojure.core/dorun {:var-kind nil, :macro nil, :lazy false, :warn-if-ret-val-unused false},
 clojure.core/doseq {:var-kind nil, :macro true},
 clojure.core/dosync {:var-kind nil, :macro true},
 clojure.core/dotimes {:var-kind nil, :macro true},
 clojure.core/doto {:var-kind nil, :macro true},
 clojure.core/double {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/double-array {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/doubles {:var-kind nil, :macro nil},
 clojure.core/drop {:var-kind nil, :macro nil, :lazy true, :pure-fn true},
 clojure.core/drop-last {:var-kind nil, :macro nil, :lazy true, :pure-fn true},
 clojure.core/drop-while {:var-kind nil, :macro nil, :lazy true, :pure-fn-if-fn-args-pure true},
 clojure.core/empty {:var-kind nil, :macro nil, :lazy true, :pure-fn true},
 clojure.core/empty? {:var-kind nil, :macro nil, :lazy true, :pure-fn true, :predicate true},
 clojure.core/ensure {:var-kind nil, :macro nil},
 clojure.core/enumeration-seq {:var-kind nil, :macro nil, :pure-fn true},  ; TBD: pure?  lazy?
 clojure.core/error-handler {:var-kind nil, :macro nil},
 clojure.core/error-mode {:var-kind nil, :macro nil},
 clojure.core/eval {:var-kind nil, :macro nil, :evals-exprs true, :side-effect true}, ; There is a useful return value in many cases, but it is reasonably common to call eval only for its side effects
 clojure.core/even? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/every-pred {:var-kind nil, :macro nil, :pure-if-fn-args-pure true},
 clojure.core/every? {:var-kind nil, :macro nil, :lazy false, :pure-fn-if-fn-args-pure true, :predicate true},
 clojure.core/ex-data {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/ex-info {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/extend {:var-kind nil, :macro nil, :side-effect true},
 clojure.core/extend-protocol {:var-kind nil, :macro true},
 clojure.core/extend-type {:var-kind nil, :macro true},
 clojure.core/extenders {:var-kind nil, :macro nil},
 clojure.core/extends? {:var-kind nil, :macro nil, :predicate true},
 clojure.core/false? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/ffirst {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/file-seq {:var-kind nil, :macro nil, :lazy true, :warn-if-ret-val-unused true},  ; Not pure.  Ret value relies on file system state.
 clojure.core/filter {:var-kind nil, :macro nil, :lazy true, :pure-fn-if-fn-args-pure true},
 clojure.core/filterv {:var-kind nil, :macro nil, :lazy false, :pure-fn-if-fn-args-pure true},
 clojure.core/find {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/find-keyword {:var-kind nil, :macro nil, :lazy false, :warn-if-ret-val-unused true},  ; TBD: Not pure fn because ret value depends on state
 clojure.core/find-ns {:var-kind nil, :macro nil},
 clojure.core/find-protocol-impl {:var-kind nil, :macro nil},
 clojure.core/find-protocol-method {:var-kind nil, :macro nil},
 clojure.core/find-var {:var-kind nil, :macro nil},
 clojure.core/first {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/flatten {:var-kind nil, :macro nil, :lazy true, :pure-fn true},
 clojure.core/float {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/float-array {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/float? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/floats {:var-kind nil, :macro nil},
 clojure.core/flush {:var-kind nil, :macro nil, :io-fn true, :side-effect true},
 clojure.core/fn {:var-kind nil, :macro true},
 clojure.core/fn? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/fnext {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/fnil {:var-kind nil, :macro nil, :pure-if-fn-args-pure true},
 clojure.core/for {:var-kind nil, :macro true},
 clojure.core/force {:var-kind nil, :macro nil},
 clojure.core/format {:var-kind nil, :macro nil, :lazy false, :warn-if-ret-val-unused true}, ; TBD: Might also be pure fn, but that may depend on what args are passed and/or format strings are used
 clojure.core/frequencies {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/future {:var-kind nil, :macro true},
 clojure.core/future-call {:var-kind nil, :macro nil},
 clojure.core/future-cancel {:var-kind nil, :macro nil},
 clojure.core/future-cancelled? {:var-kind nil, :macro nil, :predicate true},
 clojure.core/future-done? {:var-kind nil, :macro nil, :predicate true},
 clojure.core/future? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/gen-class {:var-kind nil, :macro true},
 clojure.core/gen-interface {:var-kind nil, :macro true},
 clojure.core/gensym {:var-kind nil, :macro nil, :lazy false, :warn-if-ret-val-unused true},
 clojure.core/get {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/get-in {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/get-method {:var-kind nil, :macro nil},
 clojure.core/get-proxy-class {:var-kind nil, :macro nil},
 clojure.core/get-thread-bindings {:var-kind nil, :macro nil},
 clojure.core/get-validator {:var-kind nil, :macro nil},
 clojure.core/group-by {:var-kind nil, :macro nil, :lazy false, :pure-fn-if-fn-args-pure true},
 clojure.core/hash {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/hash-combine {:var-kind nil, :macro nil},
 clojure.core/hash-map {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/hash-ordered-coll {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/hash-set {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/hash-unordered-coll {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/identical? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/identity {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/if-let {:var-kind nil, :macro true},
 clojure.core/if-not {:var-kind nil, :macro true},
 clojure.core/if-some {:var-kind nil, :macro true},
 clojure.core/ifn? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/import {:var-kind nil, :macro true},
 clojure.core/in-ns {:var-kind nil, :macro nil, :side-effect true},
 clojure.core/inc {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/inc' {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/init-proxy {:var-kind nil, :macro nil, :side-effect true}, ; Even though it returns a value, the macro clojure.core/proxy ignores its return value for some reason.  Avoid warning about it, since it also has side effects and is normal to call while ignoring its return value.
 clojure.core/instance? {:var-kind nil, :macro nil, :predicate true},
 clojure.core/int {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/int-array {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/integer? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/interleave {:var-kind nil, :macro nil, :lazy true, :pure-fn true},
 clojure.core/intern {:var-kind nil, :macro nil, :side-effect true},
 clojure.core/interpose {:var-kind nil, :macro nil, :lazy true, :pure-fn true},
 clojure.core/into {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/into-array {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/ints {:var-kind nil, :macro nil},
 clojure.core/io! {:var-kind nil, :macro true},
 clojure.core/isa? {:var-kind nil, :macro nil},
 clojure.core/iterate {:var-kind nil, :macro nil, :lazy true, :pure-fn-if-fn-args-pure true},
 clojure.core/iterator-seq {:var-kind nil, :macro nil, :warn-if-ret-val-unused true},  ; TBD: Is this lazy, strict, or it depends on the iterator?
 clojure.core/juxt {:var-kind nil, :macro nil, :pure-if-fn-args-pure true},
 clojure.core/keep {:var-kind nil, :macro nil, :lazy true, :pure-fn-if-fn-args-pure true},
 clojure.core/keep-indexed {:var-kind nil, :macro nil, :lazy true, :pure-fn-if-fn-args-pure true},
 clojure.core/key {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/keys {:var-kind nil, :macro nil, :pure-fn true},  ; TBD: lazy?
 clojure.core/keyword {:var-kind nil, :macro nil, :lazy false, :warn-if-ret-val-unused true},  ; TBD: Pure fn?  I think maybe not because it mutates state.  Is that 'apparently pure', anyway?
 clojure.core/keyword? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/last {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/lazy-cat {:var-kind nil, :macro true},
 clojure.core/lazy-seq {:var-kind nil, :macro true},
 clojure.core/let {:var-kind nil, :macro true},
 clojure.core/letfn {:var-kind nil, :macro true},
 clojure.core/line-seq {:var-kind nil, :macro nil, :lazy true, :warn-if-ret-val-unused true},
 clojure.core/list {:var-kind nil, :macro nil, :pure-fn true},  ; TBD: lazy?
 clojure.core/list* {:var-kind nil, :macro nil, :pure-fn true},  ; TBD: lazy?
 clojure.core/list? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/load {:var-kind nil, :macro nil, :io-fn true, :evals-exprs true, :side-effect true},
 clojure.core/load-file {:var-kind nil, :macro nil, :io-fn true, :evals-exprs true, :side-effect true},
 clojure.core/load-reader {:var-kind nil, :macro nil, :io-fn true, :evals-exprs true, :side-effect true},
 clojure.core/load-string {:var-kind nil, :macro nil, :evals-exprs true},
 clojure.core/loaded-libs {:var-kind nil, :macro nil},
 clojure.core/locking {:var-kind nil, :macro true},
 clojure.core/long {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/long-array {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/longs {:var-kind nil, :macro nil},
 clojure.core/loop {:var-kind nil, :macro true},
 clojure.core/macroexpand {:var-kind nil, :macro nil, :lazy false, :warn-if-ret-val-unused true},
 clojure.core/macroexpand-1 {:var-kind nil, :macro nil, :lazy false, :warn-if-ret-val-unused true},
 clojure.core/make-array {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/make-hierarchy {:var-kind nil, :macro nil},
 clojure.core/map {:var-kind nil, :macro nil, :lazy true, :pure-fn-if-fn-args-pure true},
 clojure.core/map-entry? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/map-indexed {:var-kind nil, :macro nil, :lazy true, :pure-fn-if-fn-args-pure true},
 clojure.core/map? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/mapcat {:var-kind nil, :macro nil, :lazy true, :pure-fn-if-fn-args-pure true},
 clojure.core/mapv {:var-kind nil, :macro nil, :lazy false, :pure-fn-if-fn-args-pure true},
 clojure.core/max {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/max-key {:var-kind nil, :macro nil, :lazy false, :pure-fn-if-fn-args-pure true},
 clojure.core/memfn {:var-kind nil, :macro true},
 clojure.core/memoize {:var-kind nil, :macro nil, :pure-if-fn-args-pure true},
 clojure.core/merge {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/merge-with {:var-kind nil, :macro nil, :lazy false, :pure-fn-if-fn-args-pure true},
 clojure.core/meta {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/method-sig {:var-kind nil, :macro nil},
 clojure.core/methods {:var-kind nil, :macro nil},
 clojure.core/min {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/min-key {:var-kind nil, :macro nil, :lazy false, :pure-fn-if-fn-args-pure true},
 clojure.core/mix-collection-hash {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/mod {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/munge {:var-kind nil, :macro nil},
 clojure.core/name {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/namespace {:var-kind nil, :macro nil},
 clojure.core/namespace-munge {:var-kind nil, :macro nil},
 clojure.core/neg? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/newline {:var-kind nil, :macro nil, :io-fn true, :side-effect true},
 clojure.core/next {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/nfirst {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/nil? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/nnext {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/not {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/not-any? {:var-kind nil, :macro nil, :lazy false, :pure-fn-if-fn-args-pure true, :predicate true},
 clojure.core/not-empty {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/not-every? {:var-kind nil, :macro nil, :lazy false, :pure-fn-if-fn-args-pure true, :predicate true},
 clojure.core/not= {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/ns {:var-kind nil, :macro true},
 clojure.core/ns-aliases {:var-kind nil, :macro nil},
 clojure.core/ns-imports {:var-kind nil, :macro nil},
 clojure.core/ns-interns {:var-kind nil, :macro nil},
 clojure.core/ns-map {:var-kind nil, :macro nil},
 clojure.core/ns-name {:var-kind nil, :macro nil},
 clojure.core/ns-publics {:var-kind nil, :macro nil},
 clojure.core/ns-refers {:var-kind nil, :macro nil},
 clojure.core/ns-resolve {:var-kind nil, :macro nil},
 clojure.core/ns-unalias {:var-kind nil, :macro nil},
 clojure.core/ns-unmap {:var-kind nil, :macro nil},
 clojure.core/nth {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/nthnext {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/nthrest {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/num {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/number? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/numerator {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/object-array {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/odd? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/or {:var-kind nil, :macro true},
 clojure.core/parents {:var-kind nil, :macro nil},
 clojure.core/partial {:var-kind nil, :macro nil, :pure-if-fn-args-pure true},
 clojure.core/partition {:var-kind nil, :macro nil, :lazy true, :pure-fn true},
 clojure.core/partition-all {:var-kind nil, :macro nil, :lazy true, :pure-fn true},
 clojure.core/partition-by {:var-kind nil, :macro nil, :lazy true, :pure-fn-if-fn-args-pure true},
 clojure.core/pcalls {:var-kind nil, :macro nil, :pure-if-fn-args-pure true},
 clojure.core/peek {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/persistent! {:var-kind nil, :macro nil, :lazy false, :warn-if-ret-val-unused true},
 clojure.core/pmap {:var-kind nil, :macro nil, :lazy true, :pure-fn-if-fn-args-pure true},
 clojure.core/pop {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/pop! {:var-kind nil, :macro nil, :lazy false, :warn-if-ret-val-unused true},
 clojure.core/pop-thread-bindings {:var-kind nil, :macro nil},
 clojure.core/pos? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/pr {:var-kind nil, :macro nil, :io-fn true, :side-effect true},
 clojure.core/pr-str {:var-kind nil, :macro nil, :pure-if-fn-args-pure true},  ; TBD: There are no fn args, exactly, but I think the user can create their own pr methods for new types, and they might have side effects.
 clojure.core/prefer-method {:var-kind nil, :macro nil},
 clojure.core/prefers {:var-kind nil, :macro nil},
 clojure.core/primitives-classnames {:var-kind nil, :macro nil},
 clojure.core/print {:var-kind nil, :macro nil, :io-fn true, :side-effect true},
 clojure.core/print-ctor {:var-kind nil, :macro nil},
 clojure.core/print-dup {:var-kind nil, :macro nil},
 clojure.core/print-method {:var-kind nil, :macro nil},
 clojure.core/print-simple {:var-kind nil, :macro nil},
 clojure.core/print-str {:var-kind nil, :macro nil, :pure-if-fn-args-pure true},  ; TBD: See comments for pr-str
 clojure.core/printf {:var-kind nil, :macro nil, :io-fn true, :side-effect true},
 clojure.core/println {:var-kind nil, :macro nil, :io-fn true, :side-effect true},
 clojure.core/println-str {:var-kind nil, :macro nil, :pure-if-fn-args-pure true},  ; TBD: See comments for pr-str
 clojure.core/prn {:var-kind nil, :macro nil, :io-fn true, :side-effect true},
 clojure.core/prn-str {:var-kind nil, :macro nil, :pure-if-fn-args-pure true},  ; TBD: See comments for pr-str
 clojure.core/promise {:var-kind nil, :macro nil},
 clojure.core/proxy {:var-kind nil, :macro true},
 clojure.core/proxy-call-with-super {:var-kind nil, :macro nil},
 clojure.core/proxy-mappings {:var-kind nil, :macro nil},
 clojure.core/proxy-name {:var-kind nil, :macro nil},
 clojure.core/proxy-super {:var-kind nil, :macro true},
 clojure.core/push-thread-bindings {:var-kind nil, :macro nil, :side-effect true},
 clojure.core/pvalues {:var-kind nil, :macro true},
 clojure.core/quot {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/rand {:var-kind nil, :macro nil, :side-effect :update-prng, :lazy false, :warn-if-ret-val-unused true},
 clojure.core/rand-int {:var-kind nil, :macro nil, :side-effect :update-prng, :lazy false, :warn-if-ret-val-unused true},
 clojure.core/rand-nth {:var-kind nil, :macro nil, :side-effect :update-prng, :lazy false, :warn-if-ret-val-unused true},
 clojure.core/range {:var-kind nil, :macro nil, :lazy true, :pure-fn true},
 clojure.core/ratio? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/rational? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/rationalize {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/re-find {:var-kind nil, :macro nil, :lazy false, :warn-if-ret-val-unused true},
 clojure.core/re-groups {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/re-matcher {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/re-matches {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/re-pattern {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/re-seq {:var-kind nil, :macro nil, :lazy true, :pure-fn true},
 clojure.core/read {:var-kind nil, :macro nil, :io-fn true, :evals-exprs true, :lazy false, :warn-if-ret-val-unused true},
 clojure.core/read-line {:var-kind nil, :macro nil, :io-fn true, :evals-exprs false, :lazy false, :warn-if-ret-val-unused true},  ; Note that it never evals anything, only returns a string read from a stream
 clojure.core/read-string {:var-kind nil, :macro nil, :evals-exprs true, :lazy false, :warn-if-ret-val-unused true},
 clojure.core/reader-conditional? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/realized? {:var-kind nil, :macro nil, :lazy false, :pure-fn false, :predicate true},  ; Definitely not pure, as its return value can change over time for the same arg
 clojure.core/record? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/reduce {:var-kind nil, :macro nil, :lazy false, :pure-fn-if-fn-args-pure true},
 clojure.core/reduce-kv {:var-kind nil, :macro nil, :lazy false, :pure-fn-if-fn-args-pure true},
 clojure.core/reduced {:var-kind nil, :macro nil},
 clojure.core/reduced? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/reductions {:var-kind nil, :macro nil, :lazy true, :pure-fn-if-fn-args-pure true},
 clojure.core/ref {:var-kind nil, :macro nil},
 clojure.core/ref-history-count {:var-kind nil, :macro nil},
 clojure.core/ref-max-history {:var-kind nil, :macro nil},
 clojure.core/ref-min-history {:var-kind nil, :macro nil},
 clojure.core/ref-set {:var-kind nil, :macro nil},
 clojure.core/refer {:var-kind nil, :macro nil, :side-effect true},
 clojure.core/refer-clojure {:var-kind nil, :macro true},
 clojure.core/reify {:var-kind nil, :macro true},
 clojure.core/release-pending-sends {:var-kind nil, :macro nil},
 clojure.core/rem {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/remove {:var-kind nil, :macro nil, :lazy true, :pure-fn-if-fn-args-pure true},
 clojure.core/remove-all-methods {:var-kind nil, :macro nil},
 clojure.core/remove-method {:var-kind nil, :macro nil},
 clojure.core/remove-ns {:var-kind nil, :macro nil, :side-effect true},
 clojure.core/remove-watch {:var-kind nil, :macro nil},
 clojure.core/repeat {:var-kind nil, :macro nil, :lazy true, :pure-fn true},
 clojure.core/repeatedly {:var-kind nil, :macro nil, :lazy true, :pure-fn-if-fn-args-pure true},
 clojure.core/replace {:var-kind nil, :macro nil, :pure-fn true},  ; TBD: Strict if arg is a vector, otherwise lazy.  Not sure how to handle this.  Probably should make a :lazy :depends marking and warn about it differently, if we want to get fancy.
 clojure.core/replicate {:var-kind nil, :macro nil, :lazy true, :pure-fn true},  ; TBD: Figure out how to get deprecated flag in there automatically, without editing a file like this
 clojure.core/require {:var-kind nil, :macro nil, :io-fn true, :evals-exprs true, :side-effect true},
 clojure.core/reset! {:var-kind nil, :macro nil, :side-effect true},
 clojure.core/reset-meta! {:var-kind nil, :macro nil, :side-effect true},
 clojure.core/resolve {:var-kind nil, :macro nil},
 clojure.core/rest {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/restart-agent {:var-kind nil, :macro nil},
 clojure.core/resultset-seq {:var-kind nil, :macro nil, :lazy true, :warn-if-ret-val-unused true},  ; TBD: pure fn?
 clojure.core/reverse {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/reversible? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/rseq {:var-kind nil, :macro nil, :pure-fn true},  ; TBD: lazy?
 clojure.core/rsubseq {:var-kind nil, :macro nil, :lazy true, :pure-fn true},
 clojure.core/satisfies? {:var-kind nil, :macro nil, :predicate true},
 clojure.core/second {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/select-keys {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/send {:var-kind nil, :macro nil, :side-effect true},
 clojure.core/send-off {:var-kind nil, :macro nil, :side-effect true},
 clojure.core/send-via {:var-kind nil, :macro nil, :side-effect true},
 clojure.core/seq {:var-kind nil, :macro nil, :lazy true, :pure-fn true},  ; TBD: I think this is lazy, but better to double-check.
 clojure.core/seq? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/seque {:var-kind nil, :macro nil},  ; TBD: what categories ?
 clojure.core/sequence {:var-kind nil, :macro nil, :lazy true, :pure-fn true},
 clojure.core/sequential? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/set {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/set-agent-send-executor! {:var-kind nil, :macro nil},
 clojure.core/set-agent-send-off-executor! {:var-kind nil, :macro nil},
 clojure.core/set-error-handler! {:var-kind nil, :macro nil},
 clojure.core/set-error-mode! {:var-kind nil, :macro nil},
 clojure.core/set-validator! {:var-kind nil, :macro nil},
 clojure.core/set? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/short {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/short-array {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/shorts {:var-kind nil, :macro nil},
 clojure.core/shuffle {:var-kind nil, :macro nil, :lazy false, :warn-if-ret-val-unused true},  ; TBD: pure fn?  Even if arg is Java array?
 clojure.core/shutdown-agents {:var-kind nil, :macro nil},
 clojure.core/slurp {:var-kind nil, :macro nil, :io-fn true, :lazy false, :warn-if-ret-val-unused true},
 clojure.core/some {:var-kind nil, :macro nil, :lazy true, :pure-fn-if-fn-args-pure true},
 clojure.core/some? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/some-> {:var-kind nil, :macro true},
 clojure.core/some->> {:var-kind nil, :macro true},
 clojure.core/some-fn {:var-kind nil, :macro nil, :pure-if-fn-args-pure true},
 clojure.core/sort {:var-kind nil, :macro nil, :lazy false, :pure-fn-if-fn-args-pure true},  ; TBD: causes side effects if arg is Java array
 clojure.core/sort-by {:var-kind nil, :macro nil, :lazy false, :pure-fn-if-fn-args-pure true},  ; TBD: causes side effects if arg is Java array
 clojure.core/sorted-map {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/sorted-map-by {:var-kind nil, :macro nil, :lazy false, :pure-fn-if-fn-args-pure true},
 clojure.core/sorted-set {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/sorted-set-by {:var-kind nil, :macro nil, :lazy false, :pure-fn-if-fn-args-pure true},
 clojure.core/sorted? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/special-symbol? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/spit {:var-kind nil, :macro nil, :io-fn true, :side-effect true},
 clojure.core/split-at {:var-kind nil, :macro nil, :lazy true, :pure-fn true},
 clojure.core/split-with {:var-kind nil, :macro nil, :lazy true, :pure-fn-if-fn-args-pure true},  ; TBD: I think this should be considered lazy, since each of the two elements of the vector returned are lazily evaluated.
 clojure.core/str {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/string? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/struct {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/struct-map {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/subs {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/subseq {:var-kind nil, :macro nil, :lazy true, :pure-fn true},
 clojure.core/subvec {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/supers {:var-kind nil, :macro nil},
 clojure.core/swap! {:var-kind nil, :macro nil, :side-effect true},  ; While there is a useful return value from swap!, it is common to ignore it.
 clojure.core/symbol {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/symbol? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/sync {:var-kind nil, :macro true},
 clojure.core/tagged-literal? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/take {:var-kind nil, :macro nil, :lazy true, :pure-fn true},
 clojure.core/take-last {:var-kind nil, :macro nil, :lazy false, :pure-fn true},  ; TBD: I am categorizing this as not lazy, because it will often force the evaluation of part of its argument, even if the return value can still be an unevaluated lazy sequence.
 clojure.core/take-nth {:var-kind nil, :macro nil, :lazy true, :pure-fn true},
 clojure.core/take-while {:var-kind nil, :macro nil, :lazy true, :pure-fn-if-fn-args-pure true},
 clojure.core/test {:var-kind nil, :macro nil},
 clojure.core/the-ns {:var-kind nil, :macro nil},
 clojure.core/thread-bound? {:var-kind nil, :macro nil, :predicate true},
 clojure.core/time {:var-kind nil, :macro true},
 clojure.core/to-array {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/to-array-2d {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/trampoline {:var-kind nil, :macro nil},
 clojure.core/transient {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/tree-seq {:var-kind nil, :macro nil, :lazy true, :pure-fn-if-fn-args-pure true},
 clojure.core/true? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/type {:var-kind nil, :macro nil, :lazy false, :pure-fn true},  ; TBD: Not quite pure.  The :type metadata of a var can be changed pretty easily.
 clojure.core/unchecked-add {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/unchecked-add-int {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/unchecked-byte {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/unchecked-char {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/unchecked-dec {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/unchecked-dec-int {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/unchecked-divide-int {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/unchecked-double {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/unchecked-float {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/unchecked-inc {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/unchecked-inc-int {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/unchecked-int {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/unchecked-long {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/unchecked-multiply {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/unchecked-multiply-int {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/unchecked-negate {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/unchecked-negate-int {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/unchecked-remainder-int {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/unchecked-short {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/unchecked-subtract {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/unchecked-subtract-int {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/underive {:var-kind nil, :macro nil},
 clojure.core/unquote {:var-kind nil, :macro nil},
 clojure.core/unquote-splicing {:var-kind nil, :macro nil},
 clojure.core/unsigned-bit-shift-right {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/update {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/update-in {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/update-proxy {:var-kind nil, :macro nil},
 clojure.core/use {:var-kind nil, :macro nil, :io-fn true, :evals-exprs true, :side-effect true},
 clojure.core/val {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/vals {:var-kind nil, :macro nil, :pure-fn true},  ; TBD: lazy?  See also keys, which probably has same answer.
 clojure.core/var-get {:var-kind nil, :macro nil},
 clojure.core/var-set {:var-kind nil, :macro nil},
 clojure.core/var? {:var-kind nil, :macro nil, :predicate true},
 clojure.core/vary-meta {:var-kind nil, :macro nil, :lazy false, :pure-fn-if-fn-args-pure true},
 clojure.core/vec {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/vector {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/vector-of {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/vector? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/volatile? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/vreset! {:var-kind nil, :macro nil, :side-effect true},
 clojure.core/vswap! {:var-kind nil, :macro nil, :side-effect true},
 clojure.core/when {:var-kind nil, :macro true},
 clojure.core/when-first {:var-kind nil, :macro true},
 clojure.core/when-let {:var-kind nil, :macro true},
 clojure.core/when-not {:var-kind nil, :macro true},
 clojure.core/when-some {:var-kind nil, :macro true},
 clojure.core/while {:var-kind nil, :macro true},
 clojure.core/with-bindings {:var-kind nil, :macro true},
 clojure.core/with-bindings* {:var-kind nil, :macro nil},
 clojure.core/with-in-str {:var-kind nil, :macro true},
 clojure.core/with-loading-context {:var-kind nil, :macro true},
 clojure.core/with-local-vars {:var-kind nil, :macro true},
 clojure.core/with-meta {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/with-open {:var-kind nil, :macro true},
 clojure.core/with-out-str {:var-kind nil, :macro true},
 clojure.core/with-precision {:var-kind nil, :macro true},
 clojure.core/with-redefs {:var-kind nil, :macro true},
 clojure.core/with-redefs-fn {:var-kind nil, :macro nil},
 clojure.core/xml-seq {:var-kind nil, :macro nil, :lazy true, :pure-fn true}, ; TBD: pure?
 clojure.core/zero? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/zipmap {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.data/Diff {:var-kind nil, :macro nil},
 clojure.data/EqualityPartition {:var-kind nil, :macro nil},
 clojure.data/diff {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.data/diff-similar {:var-kind nil, :macro nil},
 clojure.data/equality-partition {:var-kind nil, :macro nil},
 clojure.edn/read {:var-kind nil, :macro nil, :io-fn true, :lazy false, :warn-if-ret-val-unused true},
 clojure.edn/read-string {:var-kind nil, :macro nil, :pure-if-fn-args-pure true},  ; TBD: purity depends upon the value of data readers
 clojure.inspector/atom? {:var-kind nil, :macro nil},
 clojure.inspector/collection-tag {:var-kind nil, :macro nil},
 clojure.inspector/get-child {:var-kind nil, :macro nil},
 clojure.inspector/get-child-count {:var-kind nil, :macro nil},
 clojure.inspector/inspect {:var-kind nil, :macro nil},
 clojure.inspector/inspect-table {:var-kind nil, :macro nil, :io-fn true, :side-effect true},
 clojure.inspector/inspect-tree {:var-kind nil, :macro nil, :io-fn true, :side-effect true},
 clojure.inspector/is-leaf {:var-kind nil, :macro nil},
 clojure.inspector/list-model {:var-kind nil, :macro nil},
 clojure.inspector/list-provider {:var-kind nil, :macro nil},
 clojure.inspector/old-table-model {:var-kind nil, :macro nil},
 clojure.inspector/table-model {:var-kind nil, :macro nil},
 clojure.inspector/tree-model {:var-kind nil, :macro nil},
 clojure.instant/parse-timestamp {:var-kind nil, :macro nil},
 clojure.instant/read-instant-calendar {:var-kind nil, :macro nil},
 clojure.instant/read-instant-date {:var-kind nil, :macro nil},
 clojure.instant/read-instant-timestamp {:var-kind nil, :macro nil},
 clojure.instant/validated {:var-kind nil, :macro nil},
 clojure.java.browse/*open-url-script* {:var-kind nil, :macro nil},
 clojure.java.browse/browse-url {:var-kind nil, :macro nil, :io-fn true, :side-effect true},
 clojure.java.io/Coercions {:var-kind nil, :macro nil},
 clojure.java.io/IOFactory {:var-kind nil, :macro nil},
 clojure.java.io/as-file {:var-kind nil, :macro nil, :lazy false, :warn-if-ret-val-unused true},  ; TBD
 clojure.java.io/as-relative-path {:var-kind nil, :macro nil, :lazy false, :warn-if-ret-val-unused true},  ; TBD: pure fn?
 clojure.java.io/as-url {:var-kind nil, :macro nil, :lazy false, :warn-if-ret-val-unused true},  ; TBD: pure fn?
 clojure.java.io/copy {:var-kind nil, :macro nil, :io-fn true, :side-effect true},
 clojure.java.io/default-streams-impl {:var-kind nil, :macro nil},
 clojure.java.io/delete-file {:var-kind nil, :macro nil, :io-fn true, :side-effect true},
 clojure.java.io/file {:var-kind nil, :macro nil, :lazy false, :warn-if-ret-val-unused true},
 clojure.java.io/input-stream {:var-kind nil, :macro nil, :io-fn true, :lazy false, :warn-if-ret-val-unused true},
 clojure.java.io/make-input-stream {:var-kind nil, :macro nil},
 clojure.java.io/make-output-stream {:var-kind nil, :macro nil},
 clojure.java.io/make-parents {:var-kind nil, :macro nil},
 clojure.java.io/make-reader {:var-kind nil, :macro nil},
 clojure.java.io/make-writer {:var-kind nil, :macro nil},
 clojure.java.io/output-stream {:var-kind nil, :macro nil, :io-fn true, :lazy false, :warn-if-ret-val-unused true},
 clojure.java.io/reader {:var-kind nil, :macro nil, :io-fn true, :lazy false, :warn-if-ret-val-unused true},
 clojure.java.io/resource {:var-kind nil, :macro nil, :io-fn true, :lazy false, :warn-if-ret-val-unused true},
 clojure.java.io/writer {:var-kind nil, :macro nil, :io-fn true, :lazy false, :warn-if-ret-val-unused true},
 clojure.java.javadoc/*core-java-api* {:var-kind nil, :macro nil},
 clojure.java.javadoc/*feeling-lucky* {:var-kind nil, :macro nil},
 clojure.java.javadoc/*feeling-lucky-url* {:var-kind nil, :macro nil},
 clojure.java.javadoc/*local-javadocs* {:var-kind nil, :macro nil},
 clojure.java.javadoc/*remote-javadocs* {:var-kind nil, :macro nil},
 clojure.java.javadoc/add-local-javadoc {:var-kind nil, :macro nil},
 clojure.java.javadoc/add-remote-javadoc {:var-kind nil, :macro nil},
 clojure.java.javadoc/javadoc {:var-kind nil, :macro nil},
 clojure.java.shell/*sh-dir* {:var-kind nil, :macro nil},
 clojure.java.shell/*sh-env* {:var-kind nil, :macro nil},
 clojure.java.shell/sh {:var-kind nil, :macro nil, :side-effect true},  ; The return value is often useful from sh, but it is perfectly acceptable to ignore it as well.
 clojure.java.shell/with-sh-dir {:var-kind nil, :macro true},
 clojure.java.shell/with-sh-env {:var-kind nil, :macro true},
 clojure.main/demunge {:var-kind nil, :macro nil},
 clojure.main/initialize {:var-kind nil, :macro nil, :side-effect true},
 clojure.main/load-script {:var-kind nil, :macro nil},
 clojure.main/main {:var-kind nil, :macro nil},
 clojure.main/repl {:var-kind nil, :macro nil, :side-effect true},
 clojure.main/repl-caught {:var-kind nil, :macro nil},
 clojure.main/repl-exception {:var-kind nil, :macro nil},
 clojure.main/repl-prompt {:var-kind nil, :macro nil},
 clojure.main/repl-read {:var-kind nil, :macro nil},
 clojure.main/repl-requires {:var-kind nil, :macro nil},
 clojure.main/root-cause {:var-kind nil, :macro nil},
 clojure.main/skip-if-eol {:var-kind nil, :macro nil, :side-effect true},
 clojure.main/skip-whitespace {:var-kind nil, :macro nil},
 clojure.main/stack-element-str {:var-kind nil, :macro nil},
 clojure.main/with-bindings {:var-kind nil, :macro true},
 clojure.main/with-read-known {:var-kind nil, :macro true},
 clojure.pprint/*print-base* {:var-kind nil, :macro nil},
 clojure.pprint/*print-miser-width* {:var-kind nil, :macro nil},
 clojure.pprint/*print-pprint-dispatch* {:var-kind nil, :macro nil},
 clojure.pprint/*print-pretty* {:var-kind nil, :macro nil},
 clojure.pprint/*print-radix* {:var-kind nil, :macro nil},
 clojure.pprint/*print-right-margin* {:var-kind nil, :macro nil},
 clojure.pprint/*print-suppress-namespaces*
 {:var-kind nil, :macro nil},
 clojure.pprint/cl-format {:var-kind nil, :macro nil, :io-fn true, :side-effect true},
 clojure.pprint/code-dispatch {:var-kind nil, :macro nil},
 clojure.pprint/formatter {:var-kind nil, :macro true},
 clojure.pprint/formatter-out {:var-kind nil, :macro true},
 clojure.pprint/fresh-line {:var-kind nil, :macro nil},
 clojure.pprint/get-pretty-writer {:var-kind nil, :macro nil},
 clojure.pprint/pp {:var-kind nil, :macro true},
 clojure.pprint/pprint {:var-kind nil, :macro nil, :io-fn true, :side-effect true},
 clojure.pprint/pprint-indent {:var-kind nil, :macro nil},
 clojure.pprint/pprint-logical-block {:var-kind nil, :macro true},
 clojure.pprint/pprint-newline {:var-kind nil, :macro nil},
 clojure.pprint/pprint-tab {:var-kind nil, :macro nil},
 clojure.pprint/print-length-loop {:var-kind nil, :macro true},
 clojure.pprint/print-table {:var-kind nil, :macro nil, :io-fn true, :side-effect true},
 clojure.pprint/set-pprint-dispatch {:var-kind nil, :macro nil},
 clojure.pprint/simple-dispatch {:var-kind nil, :macro nil},
 clojure.pprint/with-pprint-dispatch {:var-kind nil, :macro true},
 clojure.pprint/write {:var-kind nil, :macro nil},
 clojure.pprint/write-out {:var-kind nil, :macro nil},
 clojure.reflect/->AsmReflector {:var-kind nil, :macro nil},
 clojure.reflect/->Constructor {:var-kind nil, :macro nil},
 clojure.reflect/->Field {:var-kind nil, :macro nil},
 clojure.reflect/->JavaReflector {:var-kind nil, :macro nil},
 clojure.reflect/->Method {:var-kind nil, :macro nil},
 clojure.reflect/ClassResolver {:var-kind nil, :macro nil},
 clojure.reflect/Reflector {:var-kind nil, :macro nil},
 clojure.reflect/TypeReference {:var-kind nil, :macro nil},
 clojure.reflect/do-reflect {:var-kind nil, :macro nil},
 clojure.reflect/flag-descriptors {:var-kind nil, :macro nil},
 clojure.reflect/map->Constructor {:var-kind nil, :macro nil},
 clojure.reflect/map->Field {:var-kind nil, :macro nil},
 clojure.reflect/map->Method {:var-kind nil, :macro nil},
 clojure.reflect/reflect {:var-kind nil, :macro nil},
 clojure.reflect/resolve-class {:var-kind nil, :macro nil},
 clojure.reflect/type-reflect {:var-kind nil, :macro nil},
 clojure.reflect/typename {:var-kind nil, :macro nil},
 clojure.repl/apropos {:var-kind nil, :macro nil},
 clojure.repl/demunge {:var-kind nil, :macro nil},
 clojure.repl/dir {:var-kind nil, :macro true},
 clojure.repl/dir-fn {:var-kind nil, :macro nil},
 clojure.repl/doc {:var-kind nil, :macro true},
 clojure.repl/find-doc {:var-kind nil, :macro nil},
 clojure.repl/print-doc {:var-kind nil, :macro nil, :side-effect true},
 clojure.repl/pst {:var-kind nil, :macro nil},
 clojure.repl/root-cause {:var-kind nil, :macro nil},
 clojure.repl/set-break-handler! {:var-kind nil, :macro nil},
 clojure.repl/source {:var-kind nil, :macro true},
 clojure.repl/source-fn {:var-kind nil, :macro nil},
 clojure.repl/stack-element-str {:var-kind nil, :macro nil},
 clojure.repl/thread-stopper {:var-kind nil, :macro nil},
 clojure.set/difference {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.set/index {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.set/intersection {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.set/join {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.set/map-invert {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.set/project {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.set/rename {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.set/rename-keys {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.set/select {:var-kind nil, :macro nil, :lazy false, :pure-fn-if-fn-args-pure true},
 clojure.set/subset? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.set/superset? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.set/union {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.stacktrace/e {:var-kind nil, :macro nil},
 clojure.stacktrace/print-cause-trace {:var-kind nil, :macro nil, :side-effect true},
 clojure.stacktrace/print-stack-trace {:var-kind nil, :macro nil, :side-effect true},
 clojure.stacktrace/print-throwable {:var-kind nil, :macro nil, :side-effect true},
 clojure.stacktrace/print-trace-element {:var-kind nil, :macro nil, :side-effect true},
 clojure.stacktrace/root-cause {:var-kind nil, :macro nil},
 clojure.string/blank? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.string/capitalize {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.string/ends-with? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.string/escape {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.string/includes? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.string/index-of {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.string/join {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.string/last-index-of {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.string/lower-case {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.string/re-quote-replacement {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.string/replace {:var-kind nil, :macro nil, :lazy false, :pure-fn-if-fn-args-pure true},
 clojure.string/replace-first {:var-kind nil, :macro nil, :lazy false, :pure-fn-if-fn-args-pure true},
 clojure.string/reverse {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.string/split {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.string/split-lines {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.string/starts-with? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.string/trim {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.string/trim-newline {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.string/triml {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.string/trimr {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.string/upper-case {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.template/apply-template {:var-kind nil, :macro nil},
 clojure.template/do-template {:var-kind nil, :macro true},
 clojure.test.junit/*depth* {:var-kind nil, :macro nil},
 clojure.test.junit/*var-context* {:var-kind nil, :macro nil},
 clojure.test.junit/element-content {:var-kind nil, :macro nil, :side-effect true},
 clojure.test.junit/error-el {:var-kind nil, :macro nil},
 clojure.test.junit/failure-el {:var-kind nil, :macro nil},
 clojure.test.junit/finish-case {:var-kind nil, :macro nil},
 clojure.test.junit/finish-element {:var-kind nil, :macro nil, :side-effect true},
 clojure.test.junit/finish-suite {:var-kind nil, :macro nil},
 clojure.test.junit/indent {:var-kind nil, :macro nil, :side-effect true},
 clojure.test.junit/junit-report {:var-kind nil, :macro nil},
 clojure.test.junit/message-el {:var-kind nil, :macro nil},
 clojure.test.junit/package-class {:var-kind nil, :macro nil},
 clojure.test.junit/start-case {:var-kind nil, :macro nil},
 clojure.test.junit/start-element {:var-kind nil, :macro nil, :side-effect true},
 clojure.test.junit/start-suite {:var-kind nil, :macro nil},
 clojure.test.junit/suite-attrs {:var-kind nil, :macro nil},
 clojure.test.junit/test-name {:var-kind nil, :macro nil},
 clojure.test.junit/with-junit-output {:var-kind nil, :macro true},
 clojure.test.tap/print-diagnostics {:var-kind nil, :macro nil, :side-effect true},
 clojure.test.tap/print-tap-diagnostic {:var-kind nil, :macro nil, :side-effect true},
 clojure.test.tap/print-tap-fail {:var-kind nil, :macro nil, :side-effect true},
 clojure.test.tap/print-tap-pass {:var-kind nil, :macro nil, :side-effect true},
 clojure.test.tap/print-tap-plan {:var-kind nil, :macro nil, :side-effect true},
 clojure.test.tap/tap-report {:var-kind nil, :macro nil},
 clojure.test.tap/with-tap-output {:var-kind nil, :macro true},
 clojure.test/*initial-report-counters* {:var-kind nil, :macro nil},
 clojure.test/*load-tests* {:var-kind nil, :macro nil},
 clojure.test/*report-counters* {:var-kind nil, :macro nil},
 clojure.test/*stack-trace-depth* {:var-kind nil, :macro nil},
 clojure.test/*test-out* {:var-kind nil, :macro nil},
 clojure.test/*testing-contexts* {:var-kind nil, :macro nil},
 clojure.test/*testing-vars* {:var-kind nil, :macro nil},
 clojure.test/are {:var-kind nil, :macro true},
 clojure.test/assert-any {:var-kind nil, :macro nil},
 clojure.test/assert-expr {:var-kind nil, :macro nil},
 clojure.test/assert-predicate {:var-kind nil, :macro nil},
 clojure.test/compose-fixtures {:var-kind nil, :macro nil},
 clojure.test/deftest {:var-kind nil, :macro true},
 clojure.test/deftest- {:var-kind nil, :macro true},
 clojure.test/do-report {:var-kind nil, :macro nil, :side-effect true},
 clojure.test/file-position {:var-kind nil, :macro nil},
 clojure.test/function? {:var-kind nil, :macro nil},
 clojure.test/get-possibly-unbound-var {:var-kind nil, :macro nil},
 clojure.test/inc-report-counter {:var-kind nil, :macro nil, :side-effect true},
 clojure.test/is {:var-kind nil, :macro true},
 clojure.test/join-fixtures {:var-kind nil, :macro nil},
 clojure.test/report {:var-kind nil, :macro nil, :side-effect true},
 clojure.test/run-all-tests {:var-kind nil, :macro nil},
 clojure.test/run-tests {:var-kind nil, :macro nil},
 clojure.test/set-test {:var-kind nil, :macro true},
 clojure.test/successful? {:var-kind nil, :macro nil},
 clojure.test/test-all-vars {:var-kind nil, :macro nil},
 clojure.test/test-ns {:var-kind nil, :macro nil},
 clojure.test/test-var {:var-kind nil, :macro nil},
 clojure.test/testing {:var-kind nil, :macro true},
 clojure.test/testing-contexts-str {:var-kind nil, :macro nil},
 clojure.test/testing-vars-str {:var-kind nil, :macro nil},
 clojure.test/try-expr {:var-kind nil, :macro true},
 clojure.test/use-fixtures {:var-kind nil, :macro nil},
 clojure.test/with-test {:var-kind nil, :macro true},
 clojure.test/with-test-out {:var-kind nil, :macro true},
 clojure.walk/keywordize-keys {:var-kind nil, :macro nil},
 clojure.walk/macroexpand-all {:var-kind nil, :macro nil},
 clojure.walk/postwalk {:var-kind nil, :macro nil},  ; TBD :pure-if-fn-args-pure true
 clojure.walk/postwalk-demo {:var-kind nil, :macro nil},  ; TBD see postwalk
 clojure.walk/postwalk-replace {:var-kind nil, :macro nil},  ; TBD see postwalk
 clojure.walk/prewalk {:var-kind nil, :macro nil},  ; TBD see postwalk
 clojure.walk/prewalk-demo {:var-kind nil, :macro nil},  ; TBD see postwalk
 clojure.walk/prewalk-replace {:var-kind nil, :macro nil},  ; TBD see postwalk
 clojure.walk/stringify-keys {:var-kind nil, :macro nil},
 clojure.walk/walk {:var-kind nil, :macro nil},  ; TBD see postwalk
 clojure.xml/*current* {:var-kind nil, :macro nil},
 clojure.xml/*sb* {:var-kind nil, :macro nil},
 clojure.xml/*stack* {:var-kind nil, :macro nil},
 clojure.xml/*state* {:var-kind nil, :macro nil},
 clojure.xml/attrs {:var-kind nil, :macro nil},
 clojure.xml/content {:var-kind nil, :macro nil},
 clojure.xml/content-handler {:var-kind nil, :macro nil},
 clojure.xml/element {:var-kind nil, :macro nil},
 clojure.xml/emit {:var-kind nil, :macro nil},
 clojure.xml/emit-element {:var-kind nil, :macro nil, :side-effect true},
 clojure.xml/parse {:var-kind nil, :macro nil},
 clojure.xml/startparse-sax {:var-kind nil, :macro nil},
 clojure.xml/tag {:var-kind nil, :macro nil},
 clojure.zip/append-child {:var-kind nil, :macro nil},
 clojure.zip/branch? {:var-kind nil, :macro nil},
 clojure.zip/children {:var-kind nil, :macro nil},
 clojure.zip/down {:var-kind nil, :macro nil},
 clojure.zip/edit {:var-kind nil, :macro nil},
 clojure.zip/end? {:var-kind nil, :macro nil},
 clojure.zip/insert-child {:var-kind nil, :macro nil},
 clojure.zip/insert-left {:var-kind nil, :macro nil},
 clojure.zip/insert-right {:var-kind nil, :macro nil},
 clojure.zip/left {:var-kind nil, :macro nil},
 clojure.zip/leftmost {:var-kind nil, :macro nil},
 clojure.zip/lefts {:var-kind nil, :macro nil},
 clojure.zip/make-node {:var-kind nil, :macro nil},
 clojure.zip/next {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.zip/node {:var-kind nil, :macro nil},
 clojure.zip/path {:var-kind nil, :macro nil},
 clojure.zip/prev {:var-kind nil, :macro nil},
 clojure.zip/remove {:var-kind nil, :macro nil},
 clojure.zip/replace {:var-kind nil, :macro nil},
 clojure.zip/right {:var-kind nil, :macro nil},
 clojure.zip/rightmost {:var-kind nil, :macro nil},
 clojure.zip/rights {:var-kind nil, :macro nil},
 clojure.zip/root {:var-kind nil, :macro nil},
 clojure.zip/seq-zip {:var-kind nil, :macro nil},
 clojure.zip/up {:var-kind nil, :macro nil},
 clojure.zip/vector-zip {:var-kind nil, :macro nil},
 clojure.zip/xml-zip {:var-kind nil, :macro nil},
 clojure.zip/zipper {:var-kind nil, :macro nil},

 ;; Note: The vars below are from Clojure contrib libraries, with the
 ;; specified versions.  Might want to keep these in separate files
 ;; for easier tracking of independent releases.

 ;; core.cache 0.6.4-SNAPSHOT
 clojure.core.cache/clear-soft-cache! {:var-kind nil, :macro nil, :side-effect true},
 clojure.core.cache.tests/do-assoc {:var-kind nil, :macro nil, :side-effect true},
 clojure.core.cache.tests/do-dissoc {:var-kind nil, :macro nil, :side-effect true},

 ;; data.codec 0.1.1-SNAPSHOT
 clojure.data.codec.base64/encoding-transfer {:var-kind nil, :macro nil, :io-fn true, :side-effect true},
 clojure.data.codec.base64/decoding-transfer {:var-kind nil, :macro nil, :io-fn true, :side-effect true},

 ;; core.async 0.1.0-SNAPSHOT
 clojure.core.async.impl.ioc-macros/aset-object {:var-kind nil, :macro nil, :side-effect true},
 clojure.core.async.impl.ioc-macros/process-exception {:var-kind nil, :macro nil, :side-effect true},
 clojure.core.async.impl.dispatch/run {:var-kind nil, :macro nil, :side-effect true},

;; core.typed 0.2.20-SNAPSHOT
 clojure.core.typed/load-if-needed {:var-kind nil, :macro nil, :side-effect true},

;; tools.trace 0.7.6-SNAPSHOT
 clojure.tools.trace/trace-var* {:var-kind nil, :macro nil, :side-effect true},
 clojure.tools.trace/untrace-var* {:var-kind nil, :macro nil, :side-effect true},
 clojure.tools.trace/trace-ns* {:var-kind nil, :macro nil, :side-effect true},
 clojure.tools.trace/untrace-ns* {:var-kind nil, :macro nil, :side-effect true},
 clojure.tools.trace/tracer {:var-kind nil, :macro nil, :io-fn true, :side-effect true},

;; tools.reader 0.8.2-SNAPSHOT
 clojure.tools.reader/read {:var-kind nil, :macro nil, :io-fn true, :evals-exprs true, :lazy false, :warn-if-ret-val-unused true},
 clojure.tools.reader/read-string {:var-kind nil, :macro nil, :evals-exprs true, :lazy false, :warn-if-ret-val-unused true},
 clojure.tools.reader.edn/read {:var-kind nil, :macro nil, :io-fn true, :lazy false, :warn-if-ret-val-unused true},
 clojure.tools.reader.edn/read-string {:var-kind nil, :macro nil, :lazy false, :pure-if-fn-args-pure true},  ; TBD: purity depends upon the value of data readers

;; math.numeric-tower 0.0.3-SNAPSHOT
 clojure.math.numeric-tower/abs {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.math.numeric-tower/expt {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.math.numeric-tower/exact-integer-sqrt {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.math.numeric-tower/gcd {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.math.numeric-tower/lcm {:var-kind nil, :macro nil, :lazy false, :pure-fn true},

;; java.jdbc 0.3.0-SNAPSHOT
 clojure.java.jdbc/insert! {:var-kind nil, :macro nil, :lazy false, :side-effect true},
 clojure.java.jdbc/update! {:var-kind nil, :macro nil, :lazy false, :side-effect true},
 clojure.java.jdbc/db-set-rollback-only! {:var-kind nil, :macro nil, :lazy false, :side-effect true},
 clojure.java.test-jdbc/create-test-table {:var-kind nil, :macro nil, :lazy false, :side-effect true},
 clojure.java.test-jdbc/update-or-insert-values {:var-kind nil, :macro nil, :lazy false, :side-effect true},

;; data.csv 0.1.3-SNAPSHOT
 clojure.data.csv/write-cell {:var-kind nil, :macro nil, :lazy false, :io-fn true, :side-effect true},
 clojure.data.csv/write-record {:var-kind nil, :macro nil, :lazy false, :io-fn true, :side-effect true},
 clojure.data.csv/write-csv {:var-kind nil, :macro nil, :lazy false, :io-fn true, :side-effect true},

;; data.json 0.2.4-SNAPSHOT
 clojure.data.json/read {:var-kind nil, :macro nil, :io-fn true, :evals-exprs false, :lazy false, :warn-if-ret-val-unused true},
 clojure.data.json/read-str {:var-kind nil, :macro nil, :evals-exprs false, :lazy false, :warn-if-ret-val-unused true},  ; TBD: This might be a pure fn, but I do not know whether the JSON reader can call user-supplied fns or not.
 clojure.data.json/read-json {:var-kind nil, :macro nil, :lazy false, :io-fn true, :warn-if-ret-val-unused true},
 clojure.data.json/write {:var-kind nil, :macro nil, :lazy false, :io-fn true, :side-effect true},
 clojure.data.json/pprint {:var-kind nil, :macro nil, :lazy false, :io-fn true, :side-effect true},
 clojure.data.json/write-str {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.data.json/write-string {:var-kind nil, :macro nil, :lazy false, :io-fn true, :side-effect true},
 clojure.data.json/print-json {:var-kind nil, :macro nil, :lazy false, :io-fn true, :side-effect true},
 clojure.data.json/pprint-json {:var-kind nil, :macro nil, :lazy false, :io-fn true, :side-effect true},

 ;; data.priority-map 0.0.7
 clojure.data.priority-map/priority-map {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.data.priority-map/priority-map-by {:var-kind nil, :macro nil, :lazy false, :pure-fn-if-fn-args-pure true},
 clojure.data.priority-map/priority-map-keyfn {:var-kind nil, :macro nil, :lazy false, :pure-fn-if-fn-args-pure true},
 clojure.data.priority-map/priority-map-keyfn-by {:var-kind nil, :macro nil, :lazy false, :pure-fn-if-fn-args-pure true},

 ;; core.memoize 0.5.8
 clojure.core.memoize/lu {:var-kind nil, :macro nil, :pure-fn false}
 
 }
