;; See comments before function print-var-info-summary in namespace
;; eastwood.util for a description of what the data in this file is
;; used for.

;; :pure-if-fn-args-pure: for pure HOFs, and fns akin to `run!` that are generally impure, but can be considered pure if their args don't cause side-effects.

{clojure.core.protocols/CollReduce {:var-kind nil, :macro nil},
 clojure.core.protocols/IKVReduce {:var-kind nil, :macro nil},
 clojure.core.protocols/InternalReduce {:var-kind nil, :macro nil},
 clojure.core.protocols/Datafiable {:var-kind nil, :macro nil}
 clojure.core.protocols/Navigable {:var-kind nil, :macro nil}
 clojure.core.protocols/datafy {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.protocols/nav {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.protocols/arr-impl {:var-kind nil, :macro nil},
 clojure.core.protocols/coll-reduce {:var-kind nil, :macro nil},
 clojure.core.protocols/emit-array-impls {:var-kind nil, :macro true},
 clojure.core.protocols/internal-reduce {:var-kind nil, :macro nil},
 clojure.core.protocols/kv-reduce {:var-kind nil, :macro nil},
 clojure.core.reducers/->Cat {:var-kind nil, :macro nil},
 clojure.core.reducers/CollFold {:var-kind nil, :macro nil},
 clojure.core.reducers/append! {:var-kind nil, :macro nil},
 clojure.core.reducers/cat {:var-kind nil, :macro nil},
 clojure.core.reducers/coll-fold {:var-kind nil, :macro nil},
 clojure.core.reducers/drop {:var-kind nil, :macro nil},
 clojure.core.reducers/filter {:var-kind nil, :macro nil},
 clojure.core.reducers/fjtask {:var-kind nil, :macro nil},
 clojure.core.reducers/flatten {:var-kind nil, :macro nil},
 clojure.core.reducers/fold {:var-kind nil, :macro nil},
 clojure.core.reducers/foldcat {:var-kind nil, :macro nil},
 clojure.core.reducers/folder {:var-kind nil, :macro nil},
 clojure.core.reducers/map {:var-kind nil, :macro nil},
 clojure.core.reducers/mapcat {:var-kind nil, :macro nil},
 clojure.core.reducers/monoid {:var-kind nil, :macro nil},
 clojure.core.reducers/pool {:var-kind nil, :macro nil},
 clojure.core.reducers/reduce {:var-kind nil, :macro nil},
 clojure.core.reducers/reducer {:var-kind nil, :macro nil},
 clojure.core.reducers/remove {:var-kind nil, :macro nil},
 clojure.core.reducers/take {:var-kind nil, :macro nil},
 clojure.core.reducers/take-while {:var-kind nil, :macro nil},
 clojure.core/* {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/*' {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/*1 {:var-kind nil, :macro nil},
 clojure.core/*2 {:var-kind nil, :macro nil},
 clojure.core/*3 {:var-kind nil, :macro nil},
 clojure.core/*agent* {:var-kind nil, :macro nil},
 clojure.core/*allow-unresolved-vars* {:var-kind nil, :macro nil},
 clojure.core/*assert* {:var-kind nil, :macro nil},
 clojure.core/*clojure-version* {:var-kind nil, :macro nil},
 clojure.core/*command-line-args* {:var-kind nil, :macro nil},
 clojure.core/*compile-files* {:var-kind nil, :macro nil},
 clojure.core/*compile-path* {:var-kind nil, :macro nil},
 clojure.core/*compiler-options* {:var-kind nil, :macro nil},
 clojure.core/*data-readers* {:var-kind nil, :macro nil},
 clojure.core/*default-data-reader-fn* {:var-kind nil, :macro nil},
 clojure.core/*e {:var-kind nil, :macro nil},
 clojure.core/*err* {:var-kind nil, :macro nil},
 clojure.core/*file* {:var-kind nil, :macro nil},
 clojure.core/*flush-on-newline* {:var-kind nil, :macro nil},
 clojure.core/*fn-loader* {:var-kind nil, :macro nil},
 clojure.core/*in* {:var-kind nil, :macro nil},
 clojure.core/*math-context* {:var-kind nil, :macro nil},
 clojure.core/*ns* {:var-kind nil, :macro nil},
 clojure.core/*out* {:var-kind nil, :macro nil},
 clojure.core/*print-dup* {:var-kind nil, :macro nil},
 clojure.core/*print-length* {:var-kind nil, :macro nil},
 clojure.core/*print-level* {:var-kind nil, :macro nil},
 clojure.core/*print-meta* {:var-kind nil, :macro nil},
 clojure.core/*print-readably* {:var-kind nil, :macro nil},
 clojure.core/*read-eval* {:var-kind nil, :macro nil},
 clojure.core/*source-path* {:var-kind nil, :macro nil},
 clojure.core/*unchecked-math* {:var-kind nil, :macro nil},
 clojure.core/*use-context-classloader* {:var-kind nil, :macro nil},
 clojure.core/*verbose-defrecords* {:var-kind nil, :macro nil},
 clojure.core/*warn-on-reflection* {:var-kind nil, :macro nil},
 clojure.core/+ {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/+' {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/- {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/-' {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/-> {:var-kind nil, :macro true},
 clojure.core/->> {:var-kind nil, :macro true},
 clojure.core/->ArrayChunk {:var-kind nil, :macro nil},
 clojure.core/->Vec {:var-kind nil, :macro nil},
 clojure.core/->VecNode {:var-kind nil, :macro nil},
 clojure.core/->VecSeq {:var-kind nil, :macro nil},
 clojure.core/-cache-protocol-fn {:var-kind nil, :macro nil},
 clojure.core/-reset-methods {:var-kind nil, :macro nil, :side-effect true},
 clojure.core/.. {:var-kind nil, :macro true},
 clojure.core// {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/< {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/<= {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/= {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/== {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/> {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/>= {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/EMPTY-NODE {:var-kind nil, :macro nil},
 clojure.core/Throwable->map {:var-kind nil, :macro nil, :lazy false, :pure-fn true}
 clojure.core/accessor {:var-kind nil, :macro nil},
 clojure.core/aclone {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/add-classpath {:var-kind nil, :macro nil},
 clojure.core/add-watch {:var-kind nil, :macro nil},
 clojure.core/agent {:var-kind nil, :macro nil},
 clojure.core/agent-error {:var-kind nil, :macro nil},
 clojure.core/agent-errors {:var-kind nil, :macro nil},
 clojure.core/aget {:var-kind nil, :macro nil, :lazy false, :pure-fn true}, ;; TBD: Might want a slightly different category for a function that is 'pure', but its return value depends on current contents of a mutable value
 clojure.core/alength {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/alias {:var-kind nil, :macro nil, :side-effect true},
 clojure.core/all-ns {:var-kind nil, :macro nil, :lazy false, :warn-if-ret-val-unused true},
 clojure.core/alter {:var-kind nil, :macro nil},
 clojure.core/alter-meta! {:var-kind nil, :macro nil, :side-effect true},
 clojure.core/alter-var-root {:var-kind nil, :macro nil, :side-effect true},
 clojure.core/amap {:var-kind nil, :macro true}, ;; TBD: Can this mutate its args?
 clojure.core/ancestors {:var-kind nil, :macro nil},
 clojure.core/and {:var-kind nil, :macro true},
 clojure.core/apply {:var-kind nil, :macro nil, :lazy false, :pure-fn-if-fn-args-pure true},
 clojure.core/areduce {:var-kind nil, :macro true}, ;; TBD: Same answer as amap ?
 clojure.core/array-map {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/as-> {:var-kind nil, :macro true},
 clojure.core/aset {:var-kind nil, :macro nil, :side-effect true},
 clojure.core/aset-boolean {:var-kind nil, :macro nil, :side-effect true},
 clojure.core/aset-byte {:var-kind nil, :macro nil, :side-effect true},
 clojure.core/aset-char {:var-kind nil, :macro nil, :side-effect true},
 clojure.core/aset-double {:var-kind nil, :macro nil, :side-effect true},
 clojure.core/aset-float {:var-kind nil, :macro nil, :side-effect true},
 clojure.core/aset-int {:var-kind nil, :macro nil, :side-effect true},
 clojure.core/aset-long {:var-kind nil, :macro nil, :side-effect true},
 clojure.core/aset-short {:var-kind nil, :macro nil, :side-effect true},
 clojure.core/assert {:var-kind nil, :macro true},
 clojure.core/assert-same-protocol {:var-kind nil, :macro nil, :side-effect true},
 clojure.core/assoc {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/assoc! {:var-kind nil, :macro nil, :predicate false, :side-effect true, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn false, :evals-exprs false},
 clojure.core/assoc-in {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/associative? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/atom {:var-kind nil, :macro nil},
 clojure.core/await {:var-kind nil, :macro nil},
 clojure.core/await-for {:var-kind nil, :macro nil},
 clojure.core/await1 {:var-kind nil, :macro nil},
 clojure.core/bases {:var-kind nil, :macro nil},
 clojure.core/bean {:var-kind nil, :macro nil},
 clojure.core/bigdec {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/bigint {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/biginteger {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/binding {:var-kind nil, :macro true},
 clojure.core/bit-and {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/bit-and-not {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/bit-clear {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/bit-flip {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/bit-not {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/bit-or {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/bit-set {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/bit-shift-left {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/bit-shift-right {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/bit-test {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/bit-xor {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/boolean {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/boolean-array {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/booleans {:var-kind nil, :macro nil},
 clojure.core/bound-fn {:var-kind nil, :macro true},
 clojure.core/bound-fn* {:var-kind nil, :macro nil, :warn-if-ret-val-unused true},
 clojure.core/bound? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/butlast {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/byte {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/byte-array {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/bytes {:var-kind nil, :macro nil},
 clojure.core/case {:var-kind nil, :macro true},
 clojure.core/case-fallthrough-err-impl {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core/cast {:var-kind nil, :macro nil},
 clojure.core/cat {:var-kind nil, :macro nil}, ;; TBD: Are transducer fns pure?  Does it ever make sense to call one and ignore its return value?
 clojure.core/char {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/char-array {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/char-escape-string {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/char-name-string {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/char? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/chars {:var-kind nil, :macro nil},
 clojure.core/chunk {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/chunk-append {:var-kind nil, :macro nil, :side-effect true},
 clojure.core/chunk-buffer {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/chunk-cons {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/chunk-first {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/chunk-next {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/chunk-rest {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/chunked-seq? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/class {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/class? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/clear-agent-errors {:var-kind nil, :macro nil},
 clojure.core/clojure-version {:var-kind nil, :macro nil, :lazy false, :warn-if-ret-val-unused true},
 clojure.core/coll? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/comment {:var-kind nil, :macro true},
 clojure.core/commute {:var-kind nil, :macro nil},
 clojure.core/comp {:var-kind nil, :macro nil, :pure-if-fn-args-pure true},
 clojure.core/comparator {:var-kind nil, :macro nil, :pure-if-fn-args-pure true},
 clojure.core/compare {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/compare-and-set! {:var-kind nil, :macro nil},
 clojure.core/compile {:var-kind nil, :macro nil},
 clojure.core/complement {:var-kind nil, :macro nil, :pure-if-fn-args-pure true},
 clojure.core/concat {:var-kind nil, :macro nil, :lazy true, :pure-fn true},
 clojure.core/cond {:var-kind nil, :macro true},
 clojure.core/cond-> {:var-kind nil, :macro true},
 clojure.core/cond->> {:var-kind nil, :macro true},
 clojure.core/condp {:var-kind nil, :macro true},
 clojure.core/conj {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/conj! {:var-kind nil, :macro nil, :predicate false, :side-effect true, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn false, :evals-exprs false},
 clojure.core/cons {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/constantly {:var-kind nil, :macro nil, :pure-if-fn-args-pure true},
 clojure.core/construct-proxy {:var-kind nil, :macro nil},
 clojure.core/contains? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/count {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/counted? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/create-ns {:var-kind nil, :macro nil, :side-effect true},
 clojure.core/create-struct {:var-kind nil, :macro nil},
 clojure.core/cycle {:var-kind nil, :macro nil, :lazy true, :pure-fn true},
 clojure.core/dec {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/dec' {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/decimal? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/declare {:var-kind nil, :macro true},
 clojure.core/default-data-readers {:var-kind nil, :macro nil},
 clojure.core/definline {:var-kind nil, :macro true},
 clojure.core/definterface {:var-kind nil, :macro true},
 clojure.core/defmacro {:var-kind nil, :macro true},
 clojure.core/defmethod {:var-kind nil, :macro true},
 clojure.core/defmulti {:var-kind nil, :macro true},
 clojure.core/defn {:var-kind nil, :macro true},
 clojure.core/defn- {:var-kind nil, :macro true},
 clojure.core/defonce {:var-kind nil, :macro true},
 clojure.core/defprotocol {:var-kind nil, :macro true},
 clojure.core/defrecord {:var-kind nil, :macro true},
 clojure.core/defstruct {:var-kind nil, :macro true},
 clojure.core/deftype {:var-kind nil, :macro true},
 clojure.core/delay {:var-kind nil, :macro true},
 clojure.core/delay? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/deliver {:var-kind nil, :macro nil, :side-effect true},
 clojure.core/denominator {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/deref {:var-kind nil, :macro nil, :predicate false, :side-effect true, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn false, :evals-exprs false},
 clojure.core/derive {:var-kind nil, :macro nil, :side-effect true},
 clojure.core/descendants {:var-kind nil, :macro nil},
 clojure.core/destructure {:var-kind nil, :macro nil},
 clojure.core/disj {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/disj! {:var-kind nil, :macro nil, :predicate false, :side-effect true, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn false, :evals-exprs false},
 clojure.core/dissoc {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/dissoc! {:var-kind nil, :macro nil, :predicate false, :side-effect true, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn false, :evals-exprs false},
 clojure.core/distinct {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/distinct? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/doall {:var-kind nil, :macro nil, :predicate false, :side-effect true :pure-fn false :warn-if-ret-val-unused false :lazy false, :pure-if-fn-args-pure false :io-fn false :evals-exprs false}, ;; TBD: Consider making a special warning just for this one, suggesting to use dorun instead if the return value is not needed, potentially saving memory
 clojure.core/dorun {:var-kind nil, :macro nil, :lazy false, :warn-if-ret-val-unused false},
 clojure.core/doseq {:var-kind nil, :macro true},
 clojure.core/dosync {:var-kind nil, :macro true},
 clojure.core/dotimes {:var-kind nil, :macro true},
 clojure.core/doto {:var-kind nil, :macro true},
 clojure.core/double {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/double-array {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/doubles {:var-kind nil, :macro nil},
 clojure.core/drop {:var-kind nil, :macro nil, :lazy true, :pure-fn true},
 clojure.core/drop-last {:var-kind nil, :macro nil, :lazy true, :pure-fn true},
 clojure.core/drop-while {:var-kind nil, :macro nil, :lazy true, :pure-fn-if-fn-args-pure true},
 clojure.core/empty {:var-kind nil, :macro nil, :lazy true, :pure-fn true},
 clojure.core/empty? {:var-kind nil, :macro nil, :lazy true, :pure-fn true, :predicate true},
 clojure.core/ensure {:var-kind nil, :macro nil},
 clojure.core/enumeration-seq {:var-kind nil, :macro nil, :pure-fn true}, ;; TBD: pure?  lazy?
 clojure.core/error-handler {:var-kind nil, :macro nil},
 clojure.core/error-mode {:var-kind nil, :macro nil},
 clojure.core/eval {:var-kind nil, :macro nil, :evals-exprs true, :side-effect true}, ;; There is a useful return value in many cases, but it is reasonably common to call eval only for its side effects
 clojure.core/even? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/every-pred {:var-kind nil, :macro nil, :pure-if-fn-args-pure true},
 clojure.core/every? {:var-kind nil, :macro nil, :lazy false, :pure-fn-if-fn-args-pure true, :predicate true},
 clojure.core/ex-data {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/ex-info {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/extend {:var-kind nil, :macro nil, :side-effect true},
 clojure.core/extend-protocol {:var-kind nil, :macro true},
 clojure.core/extend-type {:var-kind nil, :macro true},
 clojure.core/extenders {:var-kind nil, :macro nil},
 clojure.core/extends? {:var-kind nil, :macro nil, :predicate true},
 clojure.core/false? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/ffirst {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/file-seq {:var-kind nil, :macro nil, :lazy true, :warn-if-ret-val-unused true}, ;; Not pure.  Ret value relies on file system state.
 clojure.core/filter {:var-kind nil, :macro nil, :lazy true, :pure-fn-if-fn-args-pure true},
 clojure.core/filterv {:var-kind nil, :macro nil, :lazy false, :pure-fn-if-fn-args-pure true},
 clojure.core/find {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/find-keyword {:var-kind nil, :macro nil, :lazy false, :warn-if-ret-val-unused true}, ;; TBD: Not pure fn because ret value depends on state
 clojure.core/find-ns {:var-kind nil, :macro nil},
 clojure.core/find-protocol-impl {:var-kind nil, :macro nil},
 clojure.core/find-protocol-method {:var-kind nil, :macro nil},
 clojure.core/find-var {:var-kind nil, :macro nil},
 clojure.core/first {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/flatten {:var-kind nil, :macro nil, :lazy true, :pure-fn true},
 clojure.core/float {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/float-array {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/float? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/floats {:var-kind nil, :macro nil},
 clojure.core/flush {:var-kind nil, :macro nil, :io-fn true, :side-effect true},
 clojure.core/fn {:var-kind nil, :macro true},
 clojure.core/fn? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/fnext {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/fnil {:var-kind nil, :macro nil, :pure-if-fn-args-pure true},
 clojure.core/for {:var-kind nil, :macro true},
 clojure.core/force {:var-kind nil, :macro nil},
 clojure.core/format {:var-kind nil, :macro nil, :lazy false, :warn-if-ret-val-unused true}, ;; TBD: Might also be pure fn, but that may depend on what args are passed and/or format strings are used
 clojure.core/frequencies {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/future {:var-kind nil, :macro true},
 clojure.core/future-call {:var-kind nil, :macro nil},
 clojure.core/future-cancel {:var-kind nil, :macro nil},
 clojure.core/future-cancelled? {:var-kind nil, :macro nil, :predicate true},
 clojure.core/future-done? {:var-kind nil, :macro nil, :predicate true},
 clojure.core/future? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/gen-class {:var-kind nil, :macro true},
 clojure.core/gen-interface {:var-kind nil, :macro true},
 clojure.core/gensym {:var-kind nil, :macro nil, :lazy false, :warn-if-ret-val-unused true},
 clojure.core/get {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/get-in {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/get-method {:var-kind nil, :macro nil},
 clojure.core/get-proxy-class {:var-kind nil, :macro nil},
 clojure.core/get-thread-bindings {:var-kind nil, :macro nil},
 clojure.core/get-validator {:var-kind nil, :macro nil},
 clojure.core/group-by {:var-kind nil, :macro nil, :lazy false, :pure-fn-if-fn-args-pure true},
 clojure.core/hash {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/hash-combine {:var-kind nil, :macro nil},
 clojure.core/hash-map {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/hash-ordered-coll {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/hash-set {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/hash-unordered-coll {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/identical? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/identity {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/if-let {:var-kind nil, :macro true},
 clojure.core/if-not {:var-kind nil, :macro true},
 clojure.core/if-some {:var-kind nil, :macro true},
 clojure.core/ifn? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/import {:var-kind nil, :macro true},
 clojure.core/in-ns {:var-kind nil, :macro nil, :side-effect true},
 clojure.core/inc {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/inc' {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/init-proxy {:var-kind nil, :macro nil, :side-effect true}, ;; Even though it returns a value, the macro clojure.core/proxy ignores its return value for some reason.  Avoid warning about it, since it also has side effects and is normal to call while ignoring its return value.
 clojure.core/instance? {:var-kind nil, :macro nil, :predicate true},
 clojure.core/int {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/int-array {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/integer? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/interleave {:var-kind nil, :macro nil, :lazy true, :pure-fn true},
 clojure.core/intern {:var-kind nil, :macro nil, :side-effect true},
 clojure.core/interpose {:var-kind nil, :macro nil, :lazy true, :pure-fn true},
 clojure.core/into {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/into-array {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/ints {:var-kind nil, :macro nil},
 clojure.core/io! {:var-kind nil, :macro true},
 clojure.core/isa? {:var-kind nil, :macro nil},
 clojure.core/iterate {:var-kind nil, :macro nil, :lazy true, :pure-fn-if-fn-args-pure true},
 clojure.core/iterator-seq {:var-kind nil, :macro nil, :warn-if-ret-val-unused true}, ;; TBD: Is this lazy, strict, or it depends on the iterator?
 clojure.core/juxt {:var-kind nil, :macro nil, :pure-if-fn-args-pure true},
 clojure.core/keep {:var-kind nil, :macro nil, :lazy true, :pure-fn-if-fn-args-pure true},
 clojure.core/keep-indexed {:var-kind nil, :macro nil, :lazy true, :pure-fn-if-fn-args-pure true},
 clojure.core/key {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/keys {:var-kind nil, :macro nil, :pure-fn true}, ;; TBD: lazy?
 clojure.core/keyword {:var-kind nil, :macro nil, :lazy false, :warn-if-ret-val-unused true}, ;; TBD: Pure fn?  I think maybe not because it mutates state.  Is that 'apparently pure', anyway?
 clojure.core/keyword? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/last {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/lazy-cat {:var-kind nil, :macro true},
 clojure.core/lazy-seq {:var-kind nil, :macro true},
 clojure.core/let {:var-kind nil, :macro true},
 clojure.core/letfn {:var-kind nil, :macro true},
 clojure.core/line-seq {:var-kind nil, :macro nil, :lazy true, :warn-if-ret-val-unused true},
 clojure.core/list {:var-kind nil, :macro nil, :pure-fn true}, ;; TBD: lazy?
 clojure.core/list* {:var-kind nil, :macro nil, :pure-fn true}, ;; TBD: lazy?
 clojure.core/list? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/load {:var-kind nil, :macro nil, :io-fn true, :evals-exprs true, :side-effect true},
 clojure.core/load-file {:var-kind nil, :macro nil, :io-fn true, :evals-exprs true, :side-effect true},
 clojure.core/load-reader {:var-kind nil, :macro nil, :io-fn true, :evals-exprs true, :side-effect true},
 clojure.core/load-string {:var-kind nil, :macro nil, :evals-exprs true},
 clojure.core/loaded-libs {:var-kind nil, :macro nil},
 clojure.core/locking {:var-kind nil, :macro true},
 clojure.core/long {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/long-array {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/longs {:var-kind nil, :macro nil},
 clojure.core/loop {:var-kind nil, :macro true},
 clojure.core/macroexpand {:var-kind nil, :macro nil, :lazy false, :warn-if-ret-val-unused true},
 clojure.core/macroexpand-1 {:var-kind nil, :macro nil, :lazy false, :warn-if-ret-val-unused true},
 clojure.core/make-array {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/make-hierarchy {:var-kind nil, :macro nil},
 clojure.core/map {:var-kind nil, :macro nil, :lazy true, :pure-fn-if-fn-args-pure true},
 clojure.core/map-entry? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/map-indexed {:var-kind nil, :macro nil, :lazy true, :pure-fn-if-fn-args-pure true},
 clojure.core/map? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/mapcat {:var-kind nil, :macro nil, :lazy true, :pure-fn-if-fn-args-pure true},
 clojure.core/mapv {:var-kind nil, :macro nil, :lazy false, :pure-fn-if-fn-args-pure true},
 clojure.core/max {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/max-key {:var-kind nil, :macro nil, :lazy false, :pure-fn-if-fn-args-pure true},
 clojure.core/memfn {:var-kind nil, :macro true},
 clojure.core/memoize {:var-kind nil, :macro nil, :pure-if-fn-args-pure true},
 clojure.core/merge {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/merge-with {:var-kind nil, :macro nil, :lazy false, :pure-fn-if-fn-args-pure true},
 clojure.core/meta {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/method-sig {:var-kind nil, :macro nil},
 clojure.core/methods {:var-kind nil, :macro nil},
 clojure.core/min {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/min-key {:var-kind nil, :macro nil, :lazy false, :pure-fn-if-fn-args-pure true},
 clojure.core/mix-collection-hash {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/mod {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/munge {:var-kind nil, :macro nil},
 clojure.core/name {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/namespace {:var-kind nil, :macro nil},
 clojure.core/namespace-munge {:var-kind nil, :macro nil},
 clojure.core/neg? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/newline {:var-kind nil, :macro nil, :io-fn true, :side-effect true},
 clojure.core/next {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/nfirst {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/nil? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/nnext {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/not {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/not-any? {:var-kind nil, :macro nil, :lazy false, :pure-fn-if-fn-args-pure true, :predicate true},
 clojure.core/not-empty {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/not-every? {:var-kind nil, :macro nil, :lazy false, :pure-fn-if-fn-args-pure true, :predicate true},
 clojure.core/not= {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/ns {:var-kind nil, :macro true},
 clojure.core/ns-aliases {:var-kind nil, :macro nil},
 clojure.core/ns-imports {:var-kind nil, :macro nil},
 clojure.core/ns-interns {:var-kind nil, :macro nil},
 clojure.core/ns-map {:var-kind nil, :macro nil},
 clojure.core/ns-name {:var-kind nil, :macro nil},
 clojure.core/ns-publics {:var-kind nil, :macro nil},
 clojure.core/ns-refers {:var-kind nil, :macro nil},
 clojure.core/ns-resolve {:var-kind nil, :macro nil},
 clojure.core/ns-unalias {:var-kind nil, :macro nil},
 clojure.core/ns-unmap {:var-kind nil, :macro nil},
 clojure.core/nth {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/nthnext {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/nthrest {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/num {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/number? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/numerator {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/object-array {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/odd? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/or {:var-kind nil, :macro true},
 clojure.core/parents {:var-kind nil, :macro nil},
 clojure.core/partial {:var-kind nil, :macro nil, :pure-if-fn-args-pure true},
 clojure.core/partition {:var-kind nil, :macro nil, :lazy true, :pure-fn true},
 clojure.core/partition-all {:var-kind nil, :macro nil, :lazy true, :pure-fn true},
 clojure.core/partition-by {:var-kind nil, :macro nil, :lazy true, :pure-fn-if-fn-args-pure true},
 clojure.core/pcalls {:var-kind nil, :macro nil, :pure-if-fn-args-pure true},
 clojure.core/peek {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/persistent! {:var-kind nil, :macro nil, :predicate false, :side-effect true, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn false, :evals-exprs false},
 clojure.core/pmap {:var-kind nil, :macro nil, :lazy true, :pure-fn-if-fn-args-pure true},
 clojure.core/pop {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/pop! {:var-kind nil, :macro nil, :predicate false, :side-effect true, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn false, :evals-exprs false},
 clojure.core/pop-thread-bindings {:var-kind nil, :macro nil},
 clojure.core/pos? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/pr {:var-kind nil, :macro nil, :io-fn true, :side-effect true},
 clojure.core/pr-str {:var-kind nil, :macro nil, :pure-if-fn-args-pure true}, ;; TBD: There are no fn args, exactly, but I think the user can create their own pr methods for new types, and they might have side effects.
 clojure.core/prefer-method {:var-kind nil, :macro nil},
 clojure.core/prefers {:var-kind nil, :macro nil},
 clojure.core/primitives-classnames {:var-kind nil, :macro nil},
 clojure.core/print {:var-kind nil, :macro nil, :io-fn true, :side-effect true},
 clojure.core/print-ctor {:var-kind nil, :macro nil},
 clojure.core/print-dup {:var-kind nil, :macro nil},
 clojure.core/print-method {:var-kind nil, :macro nil},
 clojure.core/print-simple {:var-kind nil, :macro nil},
 clojure.core/print-str {:var-kind nil, :macro nil, :pure-if-fn-args-pure true}, ;; TBD: See comments for pr-str
 clojure.core/printf {:var-kind nil, :macro nil, :io-fn true, :side-effect true},
 clojure.core/println {:var-kind nil, :macro nil, :io-fn true, :side-effect true},
 clojure.core/println-str {:var-kind nil, :macro nil, :pure-if-fn-args-pure true}, ;; TBD: See comments for pr-str
 clojure.core/prn {:var-kind nil, :macro nil, :io-fn true, :side-effect true},
 clojure.core/prn-str {:var-kind nil, :macro nil, :pure-if-fn-args-pure true}, ;; TBD: See comments for pr-str
 clojure.core/promise {:var-kind nil, :macro nil},
 clojure.core/proxy {:var-kind nil, :macro true},
 clojure.core/proxy-call-with-super {:var-kind nil, :macro nil},
 clojure.core/proxy-mappings {:var-kind nil, :macro nil},
 clojure.core/proxy-name {:var-kind nil, :macro nil},
 clojure.core/proxy-super {:var-kind nil, :macro true},
 clojure.core/push-thread-bindings {:var-kind nil, :macro nil, :side-effect true},
 clojure.core/pvalues {:var-kind nil, :macro true},
 clojure.core/quot {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/rand {:var-kind nil, :macro nil, :side-effect :update-prng, :lazy false, :warn-if-ret-val-unused true},
 clojure.core/rand-int {:var-kind nil, :macro nil, :side-effect :update-prng, :lazy false, :warn-if-ret-val-unused true},
 clojure.core/rand-nth {:var-kind nil, :macro nil, :side-effect :update-prng, :lazy false, :warn-if-ret-val-unused true},
 clojure.core/range {:var-kind nil, :macro nil, :lazy true, :pure-fn true},
 clojure.core/ratio? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/rational? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/rationalize {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/re-find {:var-kind nil, :macro nil, :lazy false, :warn-if-ret-val-unused true},
 clojure.core/re-groups {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/re-matcher {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/re-matches {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/re-pattern {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/re-seq {:var-kind nil, :macro nil, :lazy true, :pure-fn true},

 ;; :warn-if-ret-val-unused was changed for `read` from `true` to `false`,
 ;; because `read` can be used for advancing positions in a pushbackreader, or to implicitly eval forms, etc:
 clojure.core/read {:var-kind nil, :macro nil, :predicate false :side-effect true :io-fn true, :pure-fn false :evals-exprs true, :pure-if-fn-args-pure false :lazy false, :warn-if-ret-val-unused false},
 clojure.core/read-line {:var-kind nil, :macro nil, :io-fn true, :evals-exprs false, :lazy false, :warn-if-ret-val-unused false}, ;; Note that it never evals anything, only returns a string read from a stream
 clojure.core/read-string {:var-kind nil, :macro nil, :evals-exprs true, :lazy false, :warn-if-ret-val-unused true},
 clojure.core/reader-conditional? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/realized? {:var-kind nil, :macro nil, :lazy false, :pure-fn false, :predicate true}, ;; Definitely not pure, as its return value can change over time for the same arg
 clojure.core/record? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/reduce {:var-kind nil, :macro nil, :lazy false, :pure-fn-if-fn-args-pure true},
 clojure.core/reduce-kv {:var-kind nil, :macro nil, :lazy false, :pure-fn-if-fn-args-pure true},
 clojure.core/reduced {:var-kind nil, :macro nil},
 clojure.core/reduced? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/reductions {:var-kind nil, :macro nil, :lazy true, :pure-fn-if-fn-args-pure true},
 clojure.core/ref {:var-kind nil, :macro nil},
 clojure.core/ref-history-count {:var-kind nil, :macro nil},
 clojure.core/ref-max-history {:var-kind nil, :macro nil},
 clojure.core/ref-min-history {:var-kind nil, :macro nil},
 clojure.core/ref-set {:var-kind nil, :macro nil},
 clojure.core/refer {:var-kind nil, :macro nil, :side-effect true},
 clojure.core/refer-clojure {:var-kind nil, :macro true},
 clojure.core/reify {:var-kind nil, :macro true},
 clojure.core/release-pending-sends {:var-kind nil, :macro nil},
 clojure.core/rem {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/remove {:var-kind nil, :macro nil, :lazy true, :pure-fn-if-fn-args-pure true},
 clojure.core/remove-all-methods {:var-kind nil, :macro nil},
 clojure.core/remove-method {:var-kind nil, :macro nil},
 clojure.core/remove-ns {:var-kind nil, :macro nil, :side-effect true},
 clojure.core/remove-watch {:var-kind nil, :macro nil},
 clojure.core/repeat {:var-kind nil, :macro nil, :lazy true, :pure-fn true},
 clojure.core/repeatedly {:var-kind nil, :macro nil, :lazy true, :pure-fn-if-fn-args-pure true},
 clojure.core/replace {:var-kind nil, :macro nil, :pure-fn true}, ;; TBD: Strict if arg is a vector, otherwise lazy.  Not sure how to handle this.  Probably should make a :lazy :depends marking and warn about it differently, if we want to get fancy.
 clojure.core/replicate {:var-kind nil, :macro nil, :lazy true, :pure-fn true}, ;; TBD: Figure out how to get deprecated flag in there automatically, without editing a file like this
 clojure.core/require {:var-kind nil, :macro nil, :io-fn true, :evals-exprs true, :side-effect true},
 clojure.core/reset! {:var-kind nil, :macro nil, :side-effect true},
 clojure.core/reset-meta! {:var-kind nil, :macro nil, :side-effect true},
 clojure.core/resolve {:var-kind nil, :macro nil},
 clojure.core/rest {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/restart-agent {:var-kind nil, :macro nil},
 clojure.core/resultset-seq {:var-kind nil, :macro nil, :lazy true, :warn-if-ret-val-unused true}, ;; TBD: pure fn?
 clojure.core/reverse {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/reversible? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/rseq {:var-kind nil, :macro nil, :pure-fn true}, ;; TBD: lazy?
 clojure.core/rsubseq {:var-kind nil, :macro nil, :lazy true, :pure-fn true},
 clojure.core/satisfies? {:var-kind nil, :macro nil, :predicate true},
 clojure.core/second {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/select-keys {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/send {:var-kind nil, :macro nil, :side-effect true},
 clojure.core/send-off {:var-kind nil, :macro nil, :side-effect true},
 clojure.core/send-via {:var-kind nil, :macro nil, :side-effect true},
 clojure.core/seq {:var-kind nil, :macro nil, :lazy true, :pure-fn true}, ;; TBD: I think this is lazy, but better to double-check.
 clojure.core/seq? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/seque {:var-kind nil, :macro nil}, ;; TBD: what categories ?
 clojure.core/sequence {:var-kind nil, :macro nil, :lazy true, :pure-fn true},
 clojure.core/sequential? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/set {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/set-agent-send-executor! {:var-kind nil, :macro nil},
 clojure.core/set-agent-send-off-executor! {:var-kind nil, :macro nil},
 clojure.core/set-error-handler! {:var-kind nil, :macro nil},
 clojure.core/set-error-mode! {:var-kind nil, :macro nil},
 clojure.core/set-validator! {:var-kind nil, :macro nil},
 clojure.core/set? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/short {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/short-array {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/shorts {:var-kind nil, :macro nil},
 clojure.core/shuffle {:var-kind nil, :macro nil, :lazy false, :warn-if-ret-val-unused true}, ;; TBD: pure fn?  Even if arg is Java array?
 clojure.core/shutdown-agents {:var-kind nil, :macro nil},
 clojure.core/slurp {:var-kind nil, :macro nil, :io-fn true, :lazy false, :warn-if-ret-val-unused false},
 clojure.core/some {:var-kind nil, :macro nil, :lazy true, :pure-fn-if-fn-args-pure true},
 clojure.core/some? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/some-> {:var-kind nil, :macro true},
 clojure.core/some->> {:var-kind nil, :macro true},
 clojure.core/some-fn {:var-kind nil, :macro nil, :pure-if-fn-args-pure true},
 clojure.core/sort {:var-kind nil, :macro nil, :lazy false, :pure-fn-if-fn-args-pure true}, ;; TBD: causes side effects if arg is Java array
 clojure.core/sort-by {:var-kind nil, :macro nil, :lazy false, :pure-fn-if-fn-args-pure true}, ;; TBD: causes side effects if arg is Java array
 clojure.core/sorted-map {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/sorted-map-by {:var-kind nil, :macro nil, :lazy false, :pure-fn-if-fn-args-pure true},
 clojure.core/sorted-set {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/sorted-set-by {:var-kind nil, :macro nil, :lazy false, :pure-fn-if-fn-args-pure true},
 clojure.core/sorted? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/special-symbol? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/spit {:var-kind nil, :macro nil, :io-fn true, :side-effect true},
 clojure.core/split-at {:var-kind nil, :macro nil, :lazy true, :pure-fn true},
 clojure.core/split-with {:var-kind nil, :macro nil, :lazy true, :pure-fn-if-fn-args-pure true}, ;; TBD: I think this should be considered lazy, since each of the two elements of the vector returned are lazily evaluated.
 clojure.core/str {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/string? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/struct {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/struct-map {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/subs {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/subseq {:var-kind nil, :macro nil, :lazy true, :pure-fn true},
 clojure.core/subvec {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/supers {:var-kind nil, :macro nil},
 clojure.core/swap! {:var-kind nil, :macro nil, :side-effect true}, ;; While there is a useful return value from swap!, it is common to ignore it.
 clojure.core/symbol {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/symbol? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/sync {:var-kind nil, :macro true},
 clojure.core/tagged-literal? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/take {:var-kind nil, :macro nil, :lazy true, :pure-fn true},
 clojure.core/take-last {:var-kind nil, :macro nil, :lazy false, :pure-fn true}, ;; TBD: I am categorizing this as not lazy, because it will often force the evaluation of part of its argument, even if the return value can still be an unevaluated lazy sequence.
 clojure.core/take-nth {:var-kind nil, :macro nil, :lazy true, :pure-fn true},
 clojure.core/take-while {:var-kind nil, :macro nil, :lazy true, :pure-fn-if-fn-args-pure true},
 clojure.core/test {:var-kind nil, :macro nil},
 clojure.core/the-ns {:var-kind nil, :macro nil},
 clojure.core/thread-bound? {:var-kind nil, :macro nil, :predicate true},
 clojure.core/time {:var-kind nil, :macro true},
 clojure.core/to-array {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/to-array-2d {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/trampoline {:var-kind nil, :macro nil},
 clojure.core/transient {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/tree-seq {:var-kind nil, :macro nil, :lazy true, :pure-fn-if-fn-args-pure true},
 clojure.core/true? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/type {:var-kind nil, :macro nil, :lazy false, :pure-fn true}, ;; TBD: Not quite pure.  The :type metadata of a var can be changed pretty easily.
 clojure.core/unchecked-add {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/unchecked-add-int {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/unchecked-byte {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/unchecked-char {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/unchecked-dec {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/unchecked-dec-int {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/unchecked-divide-int {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/unchecked-double {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/unchecked-float {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/unchecked-inc {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/unchecked-inc-int {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/unchecked-int {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/unchecked-long {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/unchecked-multiply {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/unchecked-multiply-int {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/unchecked-negate {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/unchecked-negate-int {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/unchecked-remainder-int {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/unchecked-short {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/unchecked-subtract {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/unchecked-subtract-int {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/underive {:var-kind nil, :macro nil},
 clojure.core/unquote {:var-kind nil, :macro nil},
 clojure.core/unquote-splicing {:var-kind nil, :macro nil},
 clojure.core/unsigned-bit-shift-right {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/update {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/update-in {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/update-proxy {:var-kind nil, :macro nil},
 clojure.core/use {:var-kind nil, :macro nil, :io-fn true, :evals-exprs true, :side-effect true},
 clojure.core/val {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/vals {:var-kind nil, :macro nil, :pure-fn true}, ;; TBD: lazy?  See also keys, which probably has same answer.
 clojure.core/var-get {:var-kind nil, :macro nil},
 clojure.core/var-set {:var-kind nil, :macro nil},
 clojure.core/var? {:var-kind nil, :macro nil, :predicate true},
 clojure.core/vary-meta {:var-kind nil, :macro nil, :lazy false, :pure-fn-if-fn-args-pure true},
 clojure.core/vec {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/vector {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/vector-of {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/vector? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/volatile? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/vreset! {:var-kind nil, :macro nil, :side-effect true},
 clojure.core/vswap! {:var-kind nil, :macro nil, :side-effect true},
 clojure.core/when {:var-kind nil, :macro true},
 clojure.core/when-first {:var-kind nil, :macro true},
 clojure.core/when-let {:var-kind nil, :macro true},
 clojure.core/when-not {:var-kind nil, :macro true},
 clojure.core/when-some {:var-kind nil, :macro true},
 clojure.core/while {:var-kind nil, :macro true},
 clojure.core/with-bindings {:var-kind nil, :macro true},
 clojure.core/with-bindings* {:var-kind nil, :macro nil},
 clojure.core/with-in-str {:var-kind nil, :macro true},
 clojure.core/with-loading-context {:var-kind nil, :macro true},
 clojure.core/with-local-vars {:var-kind nil, :macro true},
 clojure.core/with-meta {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/with-open {:var-kind nil, :macro true},
 clojure.core/with-out-str {:var-kind nil, :macro true},
 clojure.core/with-precision {:var-kind nil, :macro true},
 clojure.core/with-redefs {:var-kind nil, :macro true},
 clojure.core/with-redefs-fn {:var-kind nil, :macro nil},
 clojure.core/xml-seq {:var-kind nil, :macro nil, :lazy true, :pure-fn true}, ;; TBD: pure?
 clojure.core/zero? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.core/zipmap {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.core/*print-namespace-maps* {:var-kind nil, :macro nil}
 clojure.core/*reader-resolver* {:var-kind nil, :macro nil}
 clojure.core/*suppress-read* {:var-kind nil, :macro nil}
 clojure.core/->Eduction {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused  true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core/Inst {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn false, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure false, :io-fn true, :evals-exprs false}
 clojure.core/PrintWriter-on {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn false, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure false, :io-fn false, :evals-exprs false}
 clojure.core/StackTraceElement->vec {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core/add-tap {:var-kind nil, :macro nil, :predicate false, :side-effect true, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn false, :evals-exprs false}
 clojure.core/any? {:var-kind nil, :macro nil, :predicate true, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core/boolean? {:var-kind nil, :macro nil, :predicate true, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core/bounded-count {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core/bytes? {:var-kind nil, :macro nil, :predicate true, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core/completing {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core/dedupe {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn false, :warn-if-ret-val-unused true, :lazy true, :pure-if-fn-args-pure false, :io-fn false, :evals-exprs false}
 clojure.core/double? {:var-kind nil, :macro nil, :predicate true, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core/eduction {:var-kind nil, :macro nil, :predicate false, :side-effect true, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn false, :evals-exprs false}
 clojure.core/ensure-reduced {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core/ex-cause   {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core/ex-message {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core/halt-when {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn false, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core/ident? {:var-kind nil, :macro nil, :predicate true, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core/indexed? {:var-kind nil, :macro nil, :predicate true, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core/inst-ms {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn false, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure false, :io-fn false, :evals-exprs false}
 clojure.core/inst-ms* {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn false, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure false, :io-fn false, :evals-exprs false}
 clojure.core/inst? {:var-kind nil, :macro nil, :predicate true, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core/int? {:var-kind nil, :macro nil, :predicate true, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core/nat-int? {:var-kind nil, :macro nil, :predicate true, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core/neg-int? {:var-kind nil, :macro nil, :predicate true, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core/pos-int? {:var-kind nil, :macro nil, :predicate true, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core/qualified-ident? {:var-kind nil, :macro nil, :predicate true, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core/qualified-keyword? {:var-kind nil, :macro nil, :predicate true, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core/qualified-symbol? {:var-kind nil, :macro nil, :predicate true, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core/random-sample {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn false, :warn-if-ret-val-unused true, :lazy true, :pure-if-fn-args-pure false, :io-fn false, :evals-exprs false}
 clojure.core/read+string {:var-kind nil, :macro nil, :predicate false, :side-effect true, :pure-fn false, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure false, :io-fn true, :evals-exprs true}
 clojure.core/reader-conditional {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core/remove-tap {:var-kind nil, :macro nil, :predicate false, :side-effect true, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn false, :evals-exprs false}
 clojure.core/requiring-resolve {:var-kind nil, :macro nil, :predicate false, :side-effect true, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn true, :evals-exprs true}
 clojure.core/reset-vals! {:var-kind nil, :macro nil, :predicate false, :side-effect true, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn false, :evals-exprs false}
 clojure.core/run! {:var-kind nil, :macro nil, :predicate false, :side-effect true, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core/seqable? {:var-kind nil, :macro nil, :predicate true, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core/simple-ident? {:var-kind nil, :macro nil, :predicate true, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core/simple-keyword? {:var-kind nil, :macro nil, :predicate true, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core/simple-symbol? {:var-kind nil, :macro nil, :predicate true, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core/swap-vals! {:var-kind nil, :macro nil, :predicate false, :side-effect true, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn false, :evals-exprs false}
 clojure.core/tagged-literal {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core/tap> {:var-kind nil, :macro nil, :predicate false, :side-effect true, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn false, :evals-exprs false}
 clojure.core/transduce {:var-kind nil, :macro nil, :predicate false, :side-effect true, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure true, io-fn false, :evals-exprs false}
 clojure.core/unreduced {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core/uri? {:var-kind nil, :macro nil, :predicate true, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core/uuid? {:var-kind nil, :macro nil, :predicate true, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core/volatile! {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.data/Diff {:var-kind nil, :macro nil},
 clojure.data/EqualityPartition {:var-kind nil, :macro nil},
 clojure.data/diff {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.data/diff-similar {:var-kind nil, :macro nil},
 clojure.data/equality-partition {:var-kind nil, :macro nil},
 clojure.edn/read {:var-kind nil, :macro nil, :io-fn true, :lazy false, :warn-if-ret-val-unused false},
 clojure.edn/read-string {:var-kind nil, :macro nil, :pure-if-fn-args-pure true}, ;; TBD: purity depends upon the value of data readers
 clojure.inspector/atom? {:var-kind nil, :macro nil},
 clojure.inspector/collection-tag {:var-kind nil, :macro nil},
 clojure.inspector/get-child {:var-kind nil, :macro nil},
 clojure.inspector/get-child-count {:var-kind nil, :macro nil},
 clojure.inspector/inspect {:var-kind nil, :macro nil},
 clojure.inspector/inspect-table {:var-kind nil, :macro nil, :io-fn true, :side-effect true},
 clojure.inspector/inspect-tree {:var-kind nil, :macro nil, :io-fn true, :side-effect true},
 clojure.inspector/is-leaf {:var-kind nil, :macro nil},
 clojure.inspector/list-model {:var-kind nil, :macro nil},
 clojure.inspector/list-provider {:var-kind nil, :macro nil},
 clojure.inspector/old-table-model {:var-kind nil, :macro nil},
 clojure.inspector/table-model {:var-kind nil, :macro nil},
 clojure.inspector/tree-model {:var-kind nil, :macro nil},
 clojure.instant/parse-timestamp {:var-kind nil, :macro nil},
 clojure.instant/read-instant-calendar {:var-kind nil, :macro nil},
 clojure.instant/read-instant-date {:var-kind nil, :macro nil},
 clojure.instant/read-instant-timestamp {:var-kind nil, :macro nil},
 clojure.instant/validated {:var-kind nil, :macro nil},
 clojure.java.browse/*open-url-script* {:var-kind nil, :macro nil},
 clojure.java.browse/browse-url {:var-kind nil, :macro nil, :io-fn true, :side-effect true},
 clojure.java.io/Coercions {:var-kind nil, :macro nil},
 clojure.java.io/IOFactory {:var-kind nil, :macro nil},
 clojure.java.io/as-file {:var-kind nil, :macro nil, :lazy false, :warn-if-ret-val-unused true}, ;; TBD
 clojure.java.io/as-relative-path {:var-kind nil, :macro nil, :lazy false, :warn-if-ret-val-unused true}, ;; TBD: pure fn?
 clojure.java.io/as-url {:var-kind nil, :macro nil, :lazy false, :warn-if-ret-val-unused true}, ;; TBD: pure fn?
 clojure.java.io/copy {:var-kind nil, :macro nil, :io-fn true, :side-effect true},
 clojure.java.io/default-streams-impl {:var-kind nil, :macro nil},
 clojure.java.io/delete-file {:var-kind nil, :macro nil, :io-fn true, :side-effect true},
 clojure.java.io/file {:var-kind nil, :macro nil, :lazy false, :warn-if-ret-val-unused true},
 clojure.java.io/input-stream {:var-kind nil, :macro nil, :io-fn true, :lazy false, :warn-if-ret-val-unused true},
 clojure.java.io/make-input-stream {:var-kind nil, :macro nil},
 clojure.java.io/make-output-stream {:var-kind nil, :macro nil},
 clojure.java.io/make-parents {:var-kind nil, :macro nil},
 clojure.java.io/make-reader {:var-kind nil, :macro nil},
 clojure.java.io/make-writer {:var-kind nil, :macro nil},
 clojure.java.io/output-stream {:var-kind nil, :macro nil, :io-fn true, :lazy false, :warn-if-ret-val-unused true},
 clojure.java.io/reader {:var-kind nil, :macro nil, :io-fn true, :lazy false, :warn-if-ret-val-unused true},
 clojure.java.io/resource {:var-kind nil, :macro nil, :io-fn true, :lazy false, :warn-if-ret-val-unused true},
 clojure.java.io/writer {:var-kind nil, :macro nil, :io-fn true, :lazy false, :warn-if-ret-val-unused true},
 clojure.java.javadoc/*core-java-api* {:var-kind nil, :macro nil},
 clojure.java.javadoc/*feeling-lucky* {:var-kind nil, :macro nil},
 clojure.java.javadoc/*feeling-lucky-url* {:var-kind nil, :macro nil},
 clojure.java.javadoc/*local-javadocs* {:var-kind nil, :macro nil},
 clojure.java.javadoc/*remote-javadocs* {:var-kind nil, :macro nil},
 clojure.java.javadoc/add-local-javadoc {:var-kind nil, :macro nil},
 clojure.java.javadoc/add-remote-javadoc {:var-kind nil, :macro nil},
 clojure.java.javadoc/javadoc {:var-kind nil, :macro nil},
 clojure.java.shell/*sh-dir* {:var-kind nil, :macro nil},
 clojure.java.shell/*sh-env* {:var-kind nil, :macro nil},
 clojure.java.shell/sh {:var-kind nil, :macro nil, :side-effect true}, ;; The return value is often useful from sh, but it is perfectly acceptable to ignore it as well.
 clojure.java.shell/with-sh-dir {:var-kind nil, :macro true},
 clojure.java.shell/with-sh-env {:var-kind nil, :macro true},
 clojure.main/demunge {:var-kind nil, :macro nil},
 clojure.main/initialize {:var-kind nil, :macro nil, :side-effect true},
 clojure.main/load-script {:var-kind nil, :macro nil},
 clojure.main/main {:var-kind nil, :macro nil},
 clojure.main/repl {:var-kind nil, :macro nil, :side-effect true},
 clojure.main/repl-caught {:var-kind nil, :macro nil},
 clojure.main/repl-exception {:var-kind nil, :macro nil},
 clojure.main/repl-prompt {:var-kind nil, :macro nil},
 clojure.main/repl-read {:var-kind nil, :macro nil},
 clojure.main/repl-requires {:var-kind nil, :macro nil},
 clojure.main/root-cause {:var-kind nil, :macro nil},
 clojure.main/skip-if-eol {:var-kind nil, :macro nil, :side-effect true},
 clojure.main/skip-whitespace {:var-kind nil, :macro nil},
 clojure.main/stack-element-str {:var-kind nil, :macro nil},
 clojure.main/with-bindings {:var-kind nil, :macro true},
 clojure.main/with-read-known {:var-kind nil, :macro true},

 clojure.main/err->msg {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.main/ex-str {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.main/ex-triage {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.main/renumbering-read {:var-kind nil, :macro nil, :predicate false, :side-effect true, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn true, :evals-exprs false}
 clojure.main/report-error {:var-kind nil, :macro nil, :predicate false, :side-effect true, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn true, :evals-exprs false}
 clojure.pprint/*print-base* {:var-kind nil, :macro nil},
 clojure.pprint/*print-miser-width* {:var-kind nil, :macro nil},
 clojure.pprint/*print-pprint-dispatch* {:var-kind nil, :macro nil},
 clojure.pprint/*print-pretty* {:var-kind nil, :macro nil},
 clojure.pprint/*print-radix* {:var-kind nil, :macro nil},
 clojure.pprint/*print-right-margin* {:var-kind nil, :macro nil},
 clojure.pprint/*print-suppress-namespaces*
 {:var-kind nil, :macro nil},
 clojure.pprint/cl-format {:var-kind nil, :macro nil, :io-fn true, :side-effect true},
 clojure.pprint/code-dispatch {:var-kind nil, :macro nil},
 clojure.pprint/formatter {:var-kind nil, :macro true},
 clojure.pprint/formatter-out {:var-kind nil, :macro true},
 clojure.pprint/fresh-line {:var-kind nil, :macro nil},
 clojure.pprint/get-pretty-writer {:var-kind nil, :macro nil},
 clojure.pprint/pp {:var-kind nil, :macro true},
 clojure.pprint/pprint {:var-kind nil, :macro nil, :io-fn true, :side-effect true},
 clojure.pprint/pprint-indent {:var-kind nil, :macro nil},
 clojure.pprint/pprint-logical-block {:var-kind nil, :macro true},
 clojure.pprint/pprint-newline {:var-kind nil, :macro nil},
 clojure.pprint/pprint-tab {:var-kind nil, :macro nil},
 clojure.pprint/print-length-loop {:var-kind nil, :macro true},
 clojure.pprint/print-table {:var-kind nil, :macro nil, :io-fn true, :side-effect true},
 clojure.pprint/set-pprint-dispatch {:var-kind nil, :macro nil},
 clojure.pprint/simple-dispatch {:var-kind nil, :macro nil},
 clojure.pprint/with-pprint-dispatch {:var-kind nil, :macro true},
 clojure.pprint/write {:var-kind nil, :macro nil},
 clojure.pprint/write-out {:var-kind nil, :macro nil},
 clojure.reflect/->AsmReflector {:var-kind nil, :macro nil},
 clojure.reflect/->Constructor {:var-kind nil, :macro nil},
 clojure.reflect/->Field {:var-kind nil, :macro nil},
 clojure.reflect/->JavaReflector {:var-kind nil, :macro nil},
 clojure.reflect/->Method {:var-kind nil, :macro nil},
 clojure.reflect/ClassResolver {:var-kind nil, :macro nil},
 clojure.reflect/Reflector {:var-kind nil, :macro nil},
 clojure.reflect/TypeReference {:var-kind nil, :macro nil},
 clojure.reflect/do-reflect {:var-kind nil, :macro nil},
 clojure.reflect/flag-descriptors {:var-kind nil, :macro nil},
 clojure.reflect/map->Constructor {:var-kind nil, :macro nil},
 clojure.reflect/map->Field {:var-kind nil, :macro nil},
 clojure.reflect/map->Method {:var-kind nil, :macro nil},
 clojure.reflect/reflect {:var-kind nil, :macro nil},
 clojure.reflect/resolve-class {:var-kind nil, :macro nil},
 clojure.reflect/type-reflect {:var-kind nil, :macro nil},
 clojure.reflect/typename {:var-kind nil, :macro nil},
 clojure.repl/apropos {:var-kind nil, :macro nil},
 clojure.repl/demunge {:var-kind nil, :macro nil},
 clojure.repl/dir {:var-kind nil, :macro true},
 clojure.repl/dir-fn {:var-kind nil, :macro nil},
 clojure.repl/doc {:var-kind nil, :macro true},
 clojure.repl/find-doc {:var-kind nil, :macro nil},
 clojure.repl/print-doc {:var-kind nil, :macro nil, :side-effect true},
 clojure.repl/pst {:var-kind nil, :macro nil},
 clojure.repl/root-cause {:var-kind nil, :macro nil},
 clojure.repl/set-break-handler! {:var-kind nil, :macro nil},
 clojure.repl/source {:var-kind nil, :macro true},
 clojure.repl/source-fn {:var-kind nil, :macro nil},
 clojure.repl/stack-element-str {:var-kind nil, :macro nil},
 clojure.repl/thread-stopper {:var-kind nil, :macro nil},
 clojure.set/difference {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.set/index {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.set/intersection {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.set/join {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.set/map-invert {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.set/project {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.set/rename {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.set/rename-keys {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.set/select {:var-kind nil, :macro nil, :lazy false, :pure-fn-if-fn-args-pure true},
 clojure.set/subset? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.set/superset? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.set/union {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.stacktrace/e {:var-kind nil, :macro nil},
 clojure.stacktrace/print-cause-trace {:var-kind nil, :macro nil, :side-effect true},
 clojure.stacktrace/print-stack-trace {:var-kind nil, :macro nil, :side-effect true},
 clojure.stacktrace/print-throwable {:var-kind nil, :macro nil, :side-effect true},
 clojure.stacktrace/print-trace-element {:var-kind nil, :macro nil, :side-effect true},
 clojure.stacktrace/root-cause {:var-kind nil, :macro nil},
 clojure.string/blank? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.string/capitalize {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.string/ends-with? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.string/escape {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.string/includes? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.string/index-of {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.string/join {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.string/last-index-of {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.string/lower-case {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.string/re-quote-replacement {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.string/replace {:var-kind nil, :macro nil, :lazy false, :pure-fn-if-fn-args-pure true},
 clojure.string/replace-first {:var-kind nil, :macro nil, :lazy false, :pure-fn-if-fn-args-pure true},
 clojure.string/reverse {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.string/split {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.string/split-lines {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.string/starts-with? {:var-kind nil, :macro nil, :lazy false, :pure-fn true, :predicate true},
 clojure.string/trim {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.string/trim-newline {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.string/triml {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.string/trimr {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.string/upper-case {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.template/apply-template {:var-kind nil, :macro nil},
 clojure.template/do-template {:var-kind nil, :macro true},
 clojure.test.junit/*depth* {:var-kind nil, :macro nil},
 clojure.test.junit/*var-context* {:var-kind nil, :macro nil},
 clojure.test.junit/element-content {:var-kind nil, :macro nil, :side-effect true},
 clojure.test.junit/error-el {:var-kind nil, :macro nil},
 clojure.test.junit/failure-el {:var-kind nil, :macro nil},
 clojure.test.junit/finish-case {:var-kind nil, :macro nil},
 clojure.test.junit/finish-element {:var-kind nil, :macro nil, :side-effect true},
 clojure.test.junit/finish-suite {:var-kind nil, :macro nil},
 clojure.test.junit/indent {:var-kind nil, :macro nil, :side-effect true},
 clojure.test.junit/junit-report {:var-kind nil, :macro nil},
 clojure.test.junit/message-el {:var-kind nil, :macro nil},
 clojure.test.junit/package-class {:var-kind nil, :macro nil},
 clojure.test.junit/start-case {:var-kind nil, :macro nil},
 clojure.test.junit/start-element {:var-kind nil, :macro nil, :side-effect true},
 clojure.test.junit/start-suite {:var-kind nil, :macro nil},
 clojure.test.junit/suite-attrs {:var-kind nil, :macro nil},
 clojure.test.junit/test-name {:var-kind nil, :macro nil},
 clojure.test.junit/with-junit-output {:var-kind nil, :macro true},
 clojure.test.tap/print-diagnostics {:var-kind nil, :macro nil, :side-effect true},
 clojure.test.tap/print-tap-diagnostic {:var-kind nil, :macro nil, :side-effect true},
 clojure.test.tap/print-tap-fail {:var-kind nil, :macro nil, :side-effect true},
 clojure.test.tap/print-tap-pass {:var-kind nil, :macro nil, :side-effect true},
 clojure.test.tap/print-tap-plan {:var-kind nil, :macro nil, :side-effect true},
 clojure.test.tap/tap-report {:var-kind nil, :macro nil},
 clojure.test.tap/with-tap-output {:var-kind nil, :macro true},
 clojure.test/*initial-report-counters* {:var-kind nil, :macro nil},
 clojure.test/*load-tests* {:var-kind nil, :macro nil},
 clojure.test/*report-counters* {:var-kind nil, :macro nil},
 clojure.test/*stack-trace-depth* {:var-kind nil, :macro nil},
 clojure.test/*test-out* {:var-kind nil, :macro nil},
 clojure.test/*testing-contexts* {:var-kind nil, :macro nil},
 clojure.test/*testing-vars* {:var-kind nil, :macro nil},
 clojure.test/are {:var-kind nil, :macro true},
 clojure.test/assert-any {:var-kind nil, :macro nil},
 clojure.test/assert-expr {:var-kind nil, :macro nil},
 clojure.test/assert-predicate {:var-kind nil, :macro nil},
 clojure.test/compose-fixtures {:var-kind nil, :macro nil},
 clojure.test/deftest {:var-kind nil, :macro true},
 clojure.test/deftest- {:var-kind nil, :macro true},
 clojure.test/do-report {:var-kind nil, :macro nil, :side-effect true},
 clojure.test/file-position {:var-kind nil, :macro nil},
 clojure.test/function? {:var-kind nil, :macro nil},
 clojure.test/get-possibly-unbound-var {:var-kind nil, :macro nil},
 clojure.test/inc-report-counter {:var-kind nil, :macro nil, :side-effect true},
 clojure.test/is {:var-kind nil, :macro true},
 clojure.test/join-fixtures {:var-kind nil, :macro nil},
 clojure.test/report {:var-kind nil, :macro nil, :side-effect true},
 clojure.test/run-all-tests {:var-kind nil, :macro nil},
 clojure.test/run-tests {:var-kind nil, :macro nil},
 clojure.test/set-test {:var-kind nil, :macro true},
 clojure.test/successful? {:var-kind nil, :macro nil},
 clojure.test/test-all-vars {:var-kind nil, :macro nil},
 clojure.test/test-ns {:var-kind nil, :macro nil},
 clojure.test/test-var {:var-kind nil, :macro nil},
 clojure.test/testing {:var-kind nil, :macro true},
 clojure.test/testing-contexts-str {:var-kind nil, :macro nil},
 clojure.test/testing-vars-str {:var-kind nil, :macro nil},
 clojure.test/try-expr {:var-kind nil, :macro true},
 clojure.test/use-fixtures {:var-kind nil, :macro nil},
 clojure.test/with-test {:var-kind nil, :macro true},
 clojure.test/with-test-out {:var-kind nil, :macro true},
 clojure.test/test-vars {:var-kind nil, :macro nil, :predicate false, :side-effect true, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn false, :evals-exprs false}
 clojure.walk/keywordize-keys {:var-kind nil, :macro nil},
 clojure.walk/macroexpand-all {:var-kind nil, :macro nil},
 clojure.walk/postwalk {:var-kind nil, :macro nil}, ;; TBD :pure-if-fn-args-pure true
 clojure.walk/postwalk-demo {:var-kind nil, :macro nil}, ;; TBD see postwalk
 clojure.walk/postwalk-replace {:var-kind nil, :macro nil}, ;; TBD see postwalk
 clojure.walk/prewalk {:var-kind nil, :macro nil}, ;; TBD see postwalk
 clojure.walk/prewalk-demo {:var-kind nil, :macro nil}, ;; TBD see postwalk
 clojure.walk/prewalk-replace {:var-kind nil, :macro nil}, ;; TBD see postwalk
 clojure.walk/stringify-keys {:var-kind nil, :macro nil},
 clojure.walk/walk {:var-kind nil, :macro nil}, ;; TBD see postwalk
 clojure.xml/*current* {:var-kind nil, :macro nil},
 clojure.xml/*sb* {:var-kind nil, :macro nil},
 clojure.xml/*stack* {:var-kind nil, :macro nil},
 clojure.xml/*state* {:var-kind nil, :macro nil},
 clojure.xml/attrs {:var-kind nil, :macro nil},
 clojure.xml/content {:var-kind nil, :macro nil},
 clojure.xml/content-handler {:var-kind nil, :macro nil},
 clojure.xml/element {:var-kind nil, :macro nil},
 clojure.xml/emit {:var-kind nil, :macro nil},
 clojure.xml/emit-element {:var-kind nil, :macro nil, :side-effect true},
 clojure.xml/parse {:var-kind nil, :macro nil},
 clojure.xml/startparse-sax {:var-kind nil, :macro nil},
 clojure.xml/tag {:var-kind nil, :macro nil},
 clojure.zip/append-child {:var-kind nil, :macro nil},
 clojure.zip/branch? {:var-kind nil, :macro nil},
 clojure.zip/children {:var-kind nil, :macro nil},
 clojure.zip/down {:var-kind nil, :macro nil},
 clojure.zip/edit {:var-kind nil, :macro nil},
 clojure.zip/end? {:var-kind nil, :macro nil},
 clojure.zip/insert-child {:var-kind nil, :macro nil},
 clojure.zip/insert-left {:var-kind nil, :macro nil},
 clojure.zip/insert-right {:var-kind nil, :macro nil},
 clojure.zip/left {:var-kind nil, :macro nil},
 clojure.zip/leftmost {:var-kind nil, :macro nil},
 clojure.zip/lefts {:var-kind nil, :macro nil},
 clojure.zip/make-node {:var-kind nil, :macro nil},
 clojure.zip/next {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.zip/node {:var-kind nil, :macro nil},
 clojure.zip/path {:var-kind nil, :macro nil},
 clojure.zip/prev {:var-kind nil, :macro nil},
 clojure.zip/remove {:var-kind nil, :macro nil},
 clojure.zip/replace {:var-kind nil, :macro nil},
 clojure.zip/right {:var-kind nil, :macro nil},
 clojure.zip/rightmost {:var-kind nil, :macro nil},
 clojure.zip/rights {:var-kind nil, :macro nil},
 clojure.zip/root {:var-kind nil, :macro nil},
 clojure.zip/seq-zip {:var-kind nil, :macro nil},
 clojure.zip/up {:var-kind nil, :macro nil},
 clojure.zip/vector-zip {:var-kind nil, :macro nil},
 clojure.zip/xml-zip {:var-kind nil, :macro nil},
 clojure.zip/zipper {:var-kind nil, :macro nil},

 clojure.core.cache/clear-soft-cache! {:var-kind nil, :macro nil, :side-effect true},
 clojure.core.cache.tests/do-assoc {:var-kind nil, :macro nil, :side-effect true},
 clojure.core.cache.tests/do-dissoc {:var-kind nil, :macro nil, :side-effect true},
 clojure.core.cache/->BasicCache {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.cache/->FIFOCache {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.cache/->FnCache {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.cache/->LIRSCache {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.cache/->LRUCache {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.cache/->LUCache {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.cache/->SoftCache {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.cache/->TTLCacheQ {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.cache/CacheProtocol {:var-kind nil, :macro nil}
 clojure.core.cache/basic-cache-factory {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.cache/defcache {:var-kind nil, :macro true, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs true}
 clojure.core.cache/evict {:var-kind nil, :macro nil, :predicate false, :side-effect true, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn false, :evals-exprs false}
 clojure.core.cache/fifo-cache-factory {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.cache/has? {:var-kind nil, :macro nil, :predicate true, :side-effect false, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn false, :evals-exprs false}
 clojure.core.cache/hit {:var-kind nil, :macro nil, :predicate false, :side-effect true, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn false, :evals-exprs false}
 clojure.core.cache/lirs-cache-factory {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.cache/lookup {:var-kind nil, :macro nil, :predicate false, :side-effect true, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn false, :evals-exprs false}
 clojure.core.cache/lru-cache-factory {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.cache/lu-cache-factory {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.cache/make-reference {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.cache/miss {:var-kind nil, :macro nil, :predicate false, :side-effect true, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn false, :evals-exprs false}
 clojure.core.cache/seed {:var-kind nil, :macro nil, :predicate false, :side-effect true, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn false, :evals-exprs false}
 clojure.core.cache/soft-cache-factory {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.cache/through {:var-kind nil, :macro nil, :predicate false, :side-effect true, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn false, :evals-exprs false}
 clojure.core.cache/through-cache {:var-kind nil, :macro nil, :predicate false, :side-effect true, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn false, :evals-exprs false}
 clojure.core.cache/ttl-cache-factory {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}

 clojure.data.codec.base64/encoding-transfer {:var-kind nil, :macro nil, :io-fn true, :side-effect true},
 clojure.data.codec.base64/decoding-transfer {:var-kind nil, :macro nil, :io-fn true, :side-effect true},
 clojure.data.codec.base64/dec-length {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.data.codec.base64/decode {:var-kind nil, :macro nil, :predicate false, :side-effect true, :pure-fn false, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure false, :io-fn false, :evals-exprs false}
 clojure.data.codec.base64/decode! {:var-kind nil, :macro nil, :predicate false, :side-effect true, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn false, :evals-exprs false}
 clojure.data.codec.base64/enc-length {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.data.codec.base64/encode {:var-kind nil, :macro nil, :predicate false, :side-effect true, :pure-fn false, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure false, :io-fn false, :evals-exprs false}
 clojure.data.codec.base64/encode! {:var-kind nil, :macro nil, :predicate false, :side-effect true, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn false, :evals-exprs false}
 clojure.data.codec.base64/pad-length {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}

 clojure.core.async.impl.ioc-macros/aset-object {:var-kind nil, :macro nil, :side-effect true},
 clojure.core.async.impl.ioc-macros/process-exception {:var-kind nil, :macro nil, :side-effect true},
 clojure.core.async.impl.dispatch/run {:var-kind nil, :macro nil, :side-effect true},
 clojure.core.async.impl.dispatch/check-blocking-in-dispatch {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.dispatch/executor {:var-kind nil, :macro nil}
 clojure.core.async.impl.dispatch/in-dispatch-thread? {:var-kind nil, :macro nil, :predicate true, :side-effect false, :pure-fn false, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure false, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/->Call {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/->Case {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/->CatchHandler {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/->CondBr {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/->Const {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/->CustomTerminator {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/->Dot {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/->EndFinally {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/->Fn {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/->InstanceInterop {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/->Jmp {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/->PopTry {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/->PushTry {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/->RawCode {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/->Recur {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/->Return {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/->StaticCall {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/-item-to-ssa {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/BINDINGS-IDX {:var-kind nil, :macro nil}
 clojure.core.async.impl.ioc-macros/EXCEPTION-FRAMES {:var-kind nil, :macro nil}
 clojure.core.async.impl.ioc-macros/FN-IDX {:var-kind nil, :macro nil}
 clojure.core.async.impl.ioc-macros/IEmittableInstruction {:var-kind nil, :macro nil}
 clojure.core.async.impl.ioc-macros/IInstruction {:var-kind nil, :macro nil}
 clojure.core.async.impl.ioc-macros/ITerminator {:var-kind nil, :macro nil}
 clojure.core.async.impl.ioc-macros/STATE-IDX {:var-kind nil, :macro nil}
 clojure.core.async.impl.ioc-macros/USER-START-IDX {:var-kind nil, :macro nil}
 clojure.core.async.impl.ioc-macros/VALUE-IDX {:var-kind nil, :macro nil}
 clojure.core.async.impl.ioc-macros/add-block {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/add-instruction {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/aget-object {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn false, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure false, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/all {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/aset-all! {:var-kind nil, :macro true, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/assoc-in-plan {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/async-custom-terminators {:var-kind nil, :macro nil}
 clojure.core.async.impl.ioc-macros/block-references {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/count-persistent-values {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/debug {:var-kind nil, :macro nil, :predicate false, :side-effect true, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn true, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/emit-hinted {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/emit-instruction {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/finished? {:var-kind nil, :macro nil, :predicate true, :side-effect false, :pure-fn false, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure false, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/gen-plan {:var-kind nil, :macro true, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/get-binding {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/get-block {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/get-in-plan {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/get-plan {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/id-for-inst {:var-kind nil, :macro nil, :predicate false, :side-effect true, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/index-block {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/index-instruction {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/index-state-machine {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/instruction? {:var-kind nil, :macro nil, :predicate true, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/item-to-ssa {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/let-binding-to-ssa {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/make-env {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/map->Call {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/map->Case {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/map->CatchHandler {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/map->CondBr {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/map->Const {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/map->CustomTerminator {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/map->Dot {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/map->EndFinally {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/map->Fn {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/map->InstanceInterop {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/map->Jmp {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/map->PopTry {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/map->PushTry {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/map->RawCode {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/map->Recur {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/map->Return {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/map->StaticCall {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/mark-transitions {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/nested-go? {:var-kind nil, :macro nil, :predicate true, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/no-op {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/parse-to-state-machine {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/passes {:var-kind nil, :macro nil}
 clojure.core.async.impl.ioc-macros/pdebug {:var-kind nil, :macro nil, :predicate false, :side-effect true, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn true, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/persistent-value? {:var-kind nil, :macro nil, :predicate true, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/pop-binding {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/print-plan {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/propagate-recur {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/propagate-transitions {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/push-alter-binding {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/push-binding {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/put! {:var-kind nil, :macro nil, :predicate false, :side-effect true, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/reads-from {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/return-chan {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/run-passes {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn false, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure false, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/run-state-machine {:var-kind nil, :macro nil, :predicate false, :side-effect true, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/run-state-machine-wrapped {:var-kind nil, :macro nil, :predicate false, :side-effect true, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/set-block {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/state-machine {:var-kind nil, :macro nil, :predicate false, :side-effect true, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn false, :evals-exprs true}
 clojure.core.async.impl.ioc-macros/take! {:var-kind nil, :macro nil, :predicate false, :side-effect true, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/terminate-block {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/terminator-code {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/update-in-plan {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/var-name {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.async.impl.ioc-macros/writes-to {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}

 clojure.core.typed/load-if-needed {:var-kind nil, :macro nil, :side-effect true},

 clojure.tools.trace/trace-var* {:var-kind nil, :macro nil, :side-effect true},
 clojure.tools.trace/untrace-var* {:var-kind nil, :macro nil, :side-effect true},
 clojure.tools.trace/trace-ns* {:var-kind nil, :macro nil, :side-effect true},
 clojure.tools.trace/untrace-ns* {:var-kind nil, :macro nil, :side-effect true},
 clojure.tools.trace/tracer {:var-kind nil, :macro nil, :io-fn true, :side-effect true},

 clojure.tools.trace/ThrowableRecompose {:var-kind nil, :macro nil}
 clojure.tools.trace/clone-throwable {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure false, :io-fn false, :evals-exprs false}
 clojure.tools.trace/deftrace {:var-kind nil, :macro true, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.tools.trace/dotrace {:var-kind nil, :macro true, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.tools.trace/trace {:var-kind nil, :macro nil, :predicate false, :side-effect true, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn true, :evals-exprs false}
 clojure.tools.trace/trace-compose-throwable {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure false, :io-fn false, :evals-exprs false}
 clojure.tools.trace/trace-fn-call {:var-kind nil, :macro nil, :predicate false, :side-effect true, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn true, :evals-exprs false}
 clojure.tools.trace/trace-form {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure false, :io-fn false, :evals-exprs false}
 clojure.tools.trace/trace-forms {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure false, :io-fn false, :evals-exprs false}
 clojure.tools.trace/trace-ns {:var-kind nil, :macro true, :predicate false, :side-effect true, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn false, :evals-exprs false}
 clojure.tools.trace/trace-special-form {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure false, :io-fn false, :evals-exprs false}
 clojure.tools.trace/trace-vars {:var-kind nil, :macro true, :predicate false, :side-effect true, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn false, :evals-exprs false}
 clojure.tools.trace/traceable? {:var-kind nil, :macro nil, :predicate true, :side-effect false, :pure-fn false, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure false, :io-fn false, :evals-exprs false}
 clojure.tools.trace/traced? {:var-kind nil, :macro nil, :predicate true, :side-effect false, :pure-fn false, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure false, :io-fn false, :evals-exprs false}
 clojure.tools.trace/untrace-ns {:var-kind nil, :macro true, :predicate false, :side-effect true, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn false, :evals-exprs false}
 clojure.tools.trace/untrace-vars {:var-kind nil, :macro true, :predicate false, :side-effect true, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn false, :evals-exprs false}

 clojure.tools.reader/read {:var-kind nil, :macro nil, :io-fn true, :evals-exprs true, :lazy false, :warn-if-ret-val-unused true},
 clojure.tools.reader/read-string {:var-kind nil, :macro nil, :evals-exprs true, :lazy false, :warn-if-ret-val-unused true},
 clojure.tools.reader.edn/read {:var-kind nil, :macro nil, :io-fn true, :lazy false, :warn-if-ret-val-unused true},
 clojure.tools.reader.edn/read-string {:var-kind nil, :macro nil, :lazy false, :pure-if-fn-args-pure true}, ;; TBD: purity depends upon the value of data readers
 clojure.tools.reader/*alias-map* {:var-kind nil, :macro nil}
 clojure.tools.reader/*data-readers* {:var-kind nil, :macro nil}
 clojure.tools.reader/*default-data-reader-fn* {:var-kind nil, :macro nil}
 clojure.tools.reader/*read-delim* {:var-kind nil, :macro nil}
 clojure.tools.reader/*read-eval* {:var-kind nil, :macro nil}
 clojure.tools.reader/*suppress-read* {:var-kind nil, :macro nil}
 clojure.tools.reader/default-data-readers {:var-kind nil, :macro nil}
 clojure.tools.reader/map-func {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.tools.reader/read+string {:var-kind nil, :macro nil, :predicate false, :side-effect true, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn true, :evals-exprs true}
 clojure.tools.reader/read-regex {:var-kind nil, :macro nil, :predicate false, :side-effect true, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn true, :evals-exprs false}
 clojure.tools.reader/read-symbol {:var-kind nil, :macro nil, :predicate false, :side-effect true, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn true, :evals-exprs false}
 clojure.tools.reader/resolve-symbol {:var-kind nil, :macro false, :predicate false, :side-effect false, :pure-fn false, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure false, :io-fn false, :evals-exprs false}
 clojure.tools.reader/syntax-quote {:var-kind nil, :macro true, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}

 clojure.math.numeric-tower/abs {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.math.numeric-tower/expt {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.math.numeric-tower/exact-integer-sqrt {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.math.numeric-tower/gcd {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.math.numeric-tower/lcm {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.math.numeric-tower/MathFunctions {:var-kind nil, :macro nil}
 clojure.math.numeric-tower/ceil {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.math.numeric-tower/floor {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.math.numeric-tower/integer-length {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.math.numeric-tower/round {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.math.numeric-tower/sqrt {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.math.numeric-tower/when-available {:var-kind nil, :macro true, :predicate false, :side-effect false, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn false, :evals-exprs false}

 clojure.java.jdbc/insert! {:var-kind nil, :macro nil, :lazy false, :side-effect true},
 clojure.java.jdbc/update! {:var-kind nil, :macro nil, :lazy false, :side-effect true},
 clojure.java.jdbc/db-set-rollback-only! {:var-kind nil, :macro nil, :lazy false, :side-effect true},
 clojure.java.jdbc/Connectable {:var-kind nil, :macro nil}
 clojure.java.jdbc/IResultSetReadColumn {:var-kind nil, :macro nil}
 clojure.java.jdbc/ISQLParameter {:var-kind nil, :macro nil}
 clojure.java.jdbc/ISQLValue {:var-kind nil, :macro nil}
 clojure.java.jdbc/add-connection {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.java.jdbc/as-sql-name {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.java.jdbc/create-table-ddl {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.java.jdbc/db-connection {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.java.jdbc/db-do-commands {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn true, :evals-exprs false}
 clojure.java.jdbc/db-do-prepared {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn true, :evals-exprs false}
 clojure.java.jdbc/db-do-prepared-return-keys {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn true, :evals-exprs false}
 clojure.java.jdbc/db-find-connection {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.java.jdbc/db-is-rollback-only {:var-kind nil, :macro nil, :predicate true, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.java.jdbc/db-query-with-resultset {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn true, :evals-exprs false}
 clojure.java.jdbc/db-transaction* {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn true, :evals-exprs false}
 clojure.java.jdbc/db-unset-rollback-only! {:var-kind nil, :macro nil, :predicate false, :side-effect true, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn false, :evals-exprs false}
 clojure.java.jdbc/delete! {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn true, :evals-exprs false}
 clojure.java.jdbc/drop-table-ddl {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.java.jdbc/execute! {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn true, :evals-exprs false}
 clojure.java.jdbc/find-by-keys {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn true, :evals-exprs false}
 clojure.java.jdbc/get-by-id {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn true, :evals-exprs false}
 clojure.java.jdbc/get-connection {:var-kind nil, :macro nil, :predicate false, :side-effect true, :pure-fn false, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure false, :io-fn true, :evals-exprs false}
 clojure.java.jdbc/get-isolation-level {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn false, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure false, :io-fn true, :evals-exprs false}
 clojure.java.jdbc/get-level {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.java.jdbc/insert-multi! {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn true, :evals-exprs false}
 clojure.java.jdbc/metadata-query {:var-kind nil, :macro true, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure false, :io-fn false, :evals-exprs false}
 clojure.java.jdbc/metadata-result {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.java.jdbc/prepare-statement {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn false, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure false, :io-fn true, :evals-exprs false}
 clojure.java.jdbc/print-sql-exception {:var-kind nil, :macro nil, :predicate false, :side-effect true, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn true, :evals-exprs false}
 clojure.java.jdbc/print-sql-exception-chain {:var-kind nil, :macro nil, :predicate false, :side-effect true, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn true, :evals-exprs false}
 clojure.java.jdbc/print-update-counts {:var-kind nil, :macro nil, :predicate false, :side-effect true, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn true, :evals-exprs false}
 clojure.java.jdbc/query {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn true, :evals-exprs false}
 clojure.java.jdbc/quoted {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.java.jdbc/reducible-query {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn true, :evals-exprs false}
 clojure.java.jdbc/reducible-result-set {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.java.jdbc/result-set-read-column {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.java.jdbc/result-set-seq {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy true, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.java.jdbc/set-parameter {:var-kind nil, :macro nil, :predicate false, :side-effect true, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn false, :evals-exprs false}
 clojure.java.jdbc/sql-value {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.java.jdbc/string-array {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.java.jdbc/when-available {:var-kind nil, :macro true, :predicate false, :side-effect false, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn false, :evals-exprs false}
 clojure.java.jdbc/with-db-connection {:var-kind nil, :macro true, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.java.jdbc/with-db-metadata {:var-kind nil, :macro true, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.java.jdbc/with-db-transaction {:var-kind nil, :macro true, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.java.test-jdbc/create-test-table {:var-kind nil, :macro nil, :lazy false, :side-effect true},
 clojure.java.test-jdbc/update-or-insert-values {:var-kind nil, :macro nil, :lazy false, :side-effect true},

 clojure.data.csv/write-cell {:var-kind nil, :macro nil, :lazy false, :io-fn true, :side-effect true},
 clojure.data.csv/write-record {:var-kind nil, :macro nil, :lazy false, :io-fn true, :side-effect true},
 clojure.data.csv/write-csv {:var-kind nil, :macro nil, :lazy false, :io-fn true, :side-effect true},
 clojure.data.csv/Read-CSV-From {:var-kind nil, :macro nil}
 clojure.data.csv/read-csv {:var-kind nil, :macro nil, :predicate false, :side-effect true, :pure-fn false, :warn-if-ret-val-unused true, :lazy true, :pure-if-fn-args-pure false, :io-fn true, :evals-exprs false}
 clojure.data.csv/read-csv-from {:var-kind nil, :macro nil, :predicate false, :side-effect true, :pure-fn false, :warn-if-ret-val-unused true, :lazy true, :pure-if-fn-args-pure false, :io-fn true, :evals-exprs false}

 clojure.data.json/read {:var-kind nil, :macro nil, :io-fn true, :evals-exprs false, :lazy false, :warn-if-ret-val-unused true},
 clojure.data.json/read-str {:var-kind nil, :macro nil, :evals-exprs false, :lazy false, :warn-if-ret-val-unused true}, ;; TBD: This might be a pure fn, but I do not know whether the JSON reader can call user-supplied fns or not.
 clojure.data.json/read-json {:var-kind nil, :macro nil, :lazy false, :io-fn true, :warn-if-ret-val-unused true},
 clojure.data.json/write {:var-kind nil, :macro nil, :lazy false, :io-fn true, :side-effect true},
 clojure.data.json/pprint {:var-kind nil, :macro nil, :lazy false, :io-fn true, :side-effect true},
 clojure.data.json/write-str {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.data.json/write-string {:var-kind nil, :macro nil, :lazy false, :io-fn true, :side-effect true},
 clojure.data.json/print-json {:var-kind nil, :macro nil, :lazy false, :io-fn true, :side-effect true},
 clojure.data.json/pprint-json {:var-kind nil, :macro nil, :lazy false, :io-fn true, :side-effect true},
 clojure.data.json/-write {:var-kind nil, :macro nil, :predicate false, :side-effect true, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn true, :evals-exprs false}
 clojure.data.json/JSONWriter {:var-kind nil, :macro nil}
 clojure.data.json/codepoint-decoder {:var-kind nil, :macro nil}
 clojure.data.json/default-read-options {:var-kind nil, :macro nil}
 clojure.data.json/default-write-options {:var-kind nil, :macro nil}
 clojure.data.json/invalid-array-exception {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.data.json/json-str {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn ,true :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.data.json/write-json {:var-kind nil, :macro nil, :predicate false, :side-effect true, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn true, :evals-exprs false}

 clojure.data.priority-map/priority-map {:var-kind nil, :macro nil, :lazy false, :pure-fn true},
 clojure.data.priority-map/priority-map-by {:var-kind nil, :macro nil, :lazy false, :pure-fn-if-fn-args-pure true},
 clojure.data.priority-map/priority-map-keyfn {:var-kind nil, :macro nil, :lazy false, :pure-fn-if-fn-args-pure true},
 clojure.data.priority-map/priority-map-keyfn-by {:var-kind nil, :macro nil, :lazy false, :pure-fn-if-fn-args-pure true},
 clojure.data.priority-map/->PersistentPriorityMap {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.data.priority-map/apply-keyfn {:var-kind nil, :macro true, :predicate false, :side-effect false, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure true, :io-fn false}
 clojure.data.priority-map/priority->set-of-items {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.data.priority-map/rsubseq {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy true, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.data.priority-map/subseq {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy true, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}

 clojure.core.memoize/lu {:var-kind nil, :macro nil, :pure-fn false}
 clojure.core.memoize/->PluggableMemoization {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.memoize/->RetryingDelay {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.memoize/build-memoizer {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.memoize/fifo {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.memoize/lazy-snapshot {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn false, :warn-if-ret-val-unused true, :lazy true, :pure-if-fn-args-pure false, :io-fn false, :evals-exprs false}
 clojure.core.memoize/lru {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.memoize/memo {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.memoize/memo-clear! {:var-kind nil, :macro nil, :predicate false, :side-effect true, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn false, :evals-exprs false}
 clojure.core.memoize/memo-fifo {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.memoize/memo-lru {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.memoize/memo-lu {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.memoize/memo-reset! {:var-kind nil, :macro nil, :predicate false, :side-effect true, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn false, :evals-exprs false}
 clojure.core.memoize/memo-swap! {:var-kind nil, :macro nil, :predicate false, :side-effect true, :pure-fn false, :warn-if-ret-val-unused false, :lazy false, :pure-if-fn-args-pure false, :io-fn false, :evals-exprs false}
 clojure.core.memoize/memo-ttl {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.memoize/memo-unwrap {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.memoize/memoized? {:var-kind nil, :macro nil, :predicate true, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.memoize/memoizer {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}
 clojure.core.memoize/snapshot {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn false, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure false, :io-fn false, :evals-exprs false}
 clojure.core.memoize/ttl {:var-kind nil, :macro nil, :predicate false, :side-effect false, :pure-fn true, :warn-if-ret-val-unused true, :lazy false, :pure-if-fn-args-pure true, :io-fn false, :evals-exprs false}}
